{"ast":null,"code":"/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║                          SCHEDULER CLASS                                   ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The Scheduler is the HEART of the operating system.                       ║\n * ║                                                                           ║\n * ║ It implements the STRATEGY DESIGN PATTERN, allowing different scheduling  ║\n * ║ algorithms to be plugged in dynamically without changing the core logic.  ║\n * ║                                                                           ║\n * ║ THE ILLUSION OF PARALLELISM                                               ║\n * ║ ─────────────────────────────                                             ║\n * ║ A single CPU can only execute ONE instruction at a time. Yet, users       ║\n * ║ perceive multiple programs running simultaneously. This \"illusion\" is     ║\n * ║ achieved through:                                                         ║\n * ║                                                                           ║\n * ║ 1. RAPID CONTEXT SWITCHING - The CPU switches between processes so fast   ║\n * ║    (thousands of times per second) that humans perceive simultaneity.     ║\n * ║                                                                           ║\n * ║ 2. TIME SLICING - Each process gets a small \"slice\" of CPU time before    ║\n * ║    the OS preempts it and gives another process a turn.                   ║\n * ║                                                                           ║\n * ║ 3. SMART SCHEDULING - The OS decides WHICH process runs next and for      ║\n * ║    HOW LONG, optimizing for various goals (fairness, throughput, etc.)    ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { ProcessState } from './Process';\n\n/**\n * ┌─────────────────────────────────────────────────────────────────────────────┐\n * │                     SCHEDULING GOALS & TRADE-OFFS                           │\n * ├─────────────────────────────────────────────────────────────────────────────┤\n * │                                                                             │\n * │  Different environments have different optimization goals:                  │\n * │                                                                             │\n * │  BATCH SYSTEMS (no human waiting):                                         │\n * │  ├─ Maximize THROUGHPUT (jobs completed per unit time)                     │\n * │  ├─ Minimize TURNAROUND TIME (arrival to completion)                       │\n * │  └─ Maximize CPU UTILIZATION (keep CPU busy)                               │\n * │                                                                             │\n * │  INTERACTIVE SYSTEMS (humans waiting):                                      │\n * │  ├─ Minimize RESPONSE TIME (time to first output)                          │\n * │  └─ Ensure FAIRNESS (no process starves)                                   │\n * │                                                                             │\n * │  REAL-TIME SYSTEMS (deadlines matter):                                      │\n * │  └─ Meet DEADLINES (absolute requirement)                                  │\n * │                                                                             │\n * │  ⚠️  These goals CONFLICT! Optimizing one often hurts another.             │\n * │      Example: High throughput may cause poor response time.                │\n * │                                                                             │\n * └─────────────────────────────────────────────────────────────────────────────┘\n */\n\n/**\n * Scheduler Class (Context in Strategy Pattern)\n * \n * Manages process scheduling and CPU time allocation.\n * The actual scheduling logic is delegated to a Strategy object.\n */\nexport class Scheduler {\n  /**\n   * Create a new Scheduler\n   * \n   * @param {SchedulingStrategy} strategy - The scheduling algorithm to use\n   */\n  constructor(strategy = null) {\n    // The currently selected scheduling strategy\n    this.strategy = strategy;\n\n    // All processes in the system\n    this.processes = [];\n\n    // Ready queue - processes waiting for CPU\n    this.readyQueue = [];\n\n    // Waiting queue - processes blocked for I/O\n    this.waitingQueue = [];\n\n    // Currently running process (only ONE in single-core simulation)\n    this.runningProcess = null;\n\n    // Completed processes\n    this.completedProcesses = [];\n\n    // Current simulation time (in arbitrary time units)\n    this.currentTime = 0;\n\n    // Is simulation currently running?\n    this.isRunning = false;\n\n    /**\n     * CONTEXT SWITCH OVERHEAD\n     * ───────────────────────\n     * In real systems, context switching has a COST:\n     * \n     * 1. Save state of current process (registers, program counter, etc.)\n     * 2. Update PCB (Process Control Block) of current process\n     * 3. Move PCB to appropriate queue\n     * 4. Select next process (scheduling algorithm runs)\n     * 5. Update PCB of new process\n     * 6. Restore state of new process\n     * 7. Flush TLB (Translation Lookaside Buffer) - very expensive!\n     * 8. Potentially reload cache lines - even more expensive!\n     * \n     * This typically takes 1-1000 microseconds depending on hardware.\n     * We simulate this with a configurable overhead value.\n     */\n    this.contextSwitchOverhead = 1; // Time units\n\n    // Is context switch currently happening?\n    this.isContextSwitching = false;\n\n    // Gantt chart data for visualization\n    this.ganttChart = [];\n\n    // Metrics tracking\n    this.metrics = {\n      totalIdleTime: 0,\n      totalContextSwitches: 0,\n      processesCompleted: 0\n    };\n\n    // Callbacks for UI updates\n    this.onStateChange = null;\n    this.onContextSwitch = null;\n    this.onProcessComplete = null;\n\n    // Time quantum remaining (for Round Robin)\n    this.quantumRemaining = 0;\n  }\n\n  /**\n   * Set the scheduling strategy (algorithm)\n   * \n   * This is the key to the Strategy Pattern - we can swap algorithms\n   * at runtime without changing any of the Scheduler's core logic.\n   * \n   * @param {SchedulingStrategy} strategy - The new scheduling strategy\n   */\n  setStrategy(strategy) {\n    this.strategy = strategy;\n    // Reset quantum when changing strategies\n    if (strategy && strategy.timeQuantum) {\n      this.quantumRemaining = strategy.timeQuantum;\n    }\n  }\n\n  /**\n   * Add a process to the system\n   * \n   * @param {Process} process - The process to add\n   */\n  addProcess(process) {\n    this.processes.push(process);\n\n    // If process has already arrived, add to ready queue\n    if (process.arrivalTime <= this.currentTime) {\n      this.admitProcess(process);\n    }\n  }\n\n  /**\n   * Admit a process to the ready queue\n   * \n   * @param {Process} process - Process to admit\n   */\n  admitProcess(process) {\n    if (process.state === ProcessState.NEW) {\n      process.setState(ProcessState.READY, this.currentTime);\n      this.readyQueue.push(process);\n\n      // Let strategy know about new process (for MLFQ queue assignment)\n      if (this.strategy && this.strategy.onProcessAdmit) {\n        this.strategy.onProcessAdmit(process);\n      }\n    }\n  }\n\n  /**\n   * Remove a process from the system (kill)\n   * \n   * @param {string} processId - ID of process to kill\n   */\n  killProcess(processId) {\n    // Find and remove from all queues\n    this.readyQueue = this.readyQueue.filter(p => p.id !== processId);\n    this.waitingQueue = this.waitingQueue.filter(p => p.id !== processId);\n    if (this.runningProcess && this.runningProcess.id === processId) {\n      this.runningProcess.setState(ProcessState.TERMINATED, this.currentTime);\n      this.runningProcess = null;\n    }\n\n    // Find in processes array and terminate\n    const process = this.processes.find(p => p.id === processId);\n    if (process && process.state !== ProcessState.TERMINATED) {\n      process.setState(ProcessState.TERMINATED, this.currentTime);\n      this.completedProcesses.push(process);\n    }\n    this.notifyStateChange();\n  }\n\n  /**\n   * Inject an I/O interrupt to the running process\n   * \n   * This simulates a process requesting I/O (disk read, network, etc.)\n   * The process moves to WAITING state and another process can run.\n   * \n   * @param {number} ioDuration - How long the I/O takes\n   */\n  injectIOInterrupt(ioDuration = 5) {\n    if (this.runningProcess) {\n      const process = this.runningProcess;\n      process.setState(ProcessState.WAITING, this.currentTime);\n      process.startIO(ioDuration);\n\n      // In MLFQ, yielding for I/O is rewarded with promotion\n      if (this.strategy && this.strategy.name === 'MLFQ') {\n        process.promote();\n      }\n      this.waitingQueue.push(process);\n      this.runningProcess = null;\n      this.notifyStateChange();\n    }\n  }\n\n  /**\n   * Perform a context switch\n   * \n   * @param {Process} nextProcess - The process to switch to\n   * @returns {Promise} - Resolves when context switch is complete\n   */\n  async performContextSwitch(nextProcess) {\n    this.isContextSwitching = true;\n    this.metrics.totalContextSwitches++;\n\n    // Notify UI about context switch starting\n    if (this.onContextSwitch) {\n      this.onContextSwitch({\n        from: this.runningProcess ? this.runningProcess.toSnapshot() : null,\n        to: nextProcess.toSnapshot(),\n        overhead: this.contextSwitchOverhead\n      });\n    }\n\n    // Record context switch in Gantt chart\n    this.ganttChart.push({\n      type: 'context_switch',\n      startTime: this.currentTime,\n      endTime: this.currentTime + this.contextSwitchOverhead\n    });\n\n    // Simulate context switch delay\n    await this.delay(this.contextSwitchOverhead * 100); // Visual delay\n\n    this.currentTime += this.contextSwitchOverhead;\n    this.isContextSwitching = false;\n    return true;\n  }\n\n  /**\n   * Execute one simulation step\n   * \n   * This is the main scheduling loop iteration.\n   * \n   * @returns {Object} - Step result with state information\n   */\n  async step() {\n    if (!this.strategy) {\n      throw new Error('No scheduling strategy set!');\n    }\n\n    // 1. Check for newly arriving processes\n    this.checkArrivals();\n\n    // 2. Check for I/O completions\n    this.checkIOCompletions();\n\n    // 3. If nothing is running, select next process\n    if (!this.runningProcess && this.readyQueue.length > 0) {\n      const nextProcess = this.strategy.selectNext(this.readyQueue, this.currentTime);\n      if (nextProcess) {\n        // Remove from ready queue\n        this.readyQueue = this.readyQueue.filter(p => p.id !== nextProcess.id);\n\n        // Perform context switch\n        await this.performContextSwitch(nextProcess);\n\n        // Start running the process\n        this.runningProcess = nextProcess;\n        nextProcess.setState(ProcessState.RUNNING, this.currentTime);\n\n        // Reset quantum for this process\n        this.quantumRemaining = this.strategy.timeQuantum || Infinity;\n      }\n    }\n\n    // 4. Execute running process for one time unit\n    if (this.runningProcess) {\n      const result = this.runningProcess.execute(1);\n\n      // Record in Gantt chart\n      this.ganttChart.push({\n        type: 'execution',\n        processId: this.runningProcess.id,\n        processName: this.runningProcess.name,\n        color: this.runningProcess.color,\n        startTime: this.currentTime,\n        endTime: this.currentTime + 1\n      });\n      this.currentTime += 1;\n      this.quantumRemaining -= 1;\n\n      // Check if process completed\n      if (result.completed) {\n        this.runningProcess.setState(ProcessState.TERMINATED, this.currentTime);\n        this.completedProcesses.push(this.runningProcess);\n        this.metrics.processesCompleted++;\n        if (this.onProcessComplete) {\n          this.onProcessComplete(this.runningProcess.toSnapshot());\n        }\n        this.runningProcess = null;\n      }\n      // Check if process requests I/O\n      else if (result.requestsIO) {\n        this.injectIOInterrupt(3 + Math.floor(Math.random() * 5));\n      }\n      // Check for preemption (quantum expired or higher priority arrived)\n      else if (this.strategy.shouldPreempt(this.runningProcess, this.readyQueue, this.quantumRemaining)) {\n        // Handle preemption based on strategy\n        this.handlePreemption();\n      }\n    } else {\n      // CPU is idle\n      this.metrics.totalIdleTime++;\n      this.ganttChart.push({\n        type: 'idle',\n        startTime: this.currentTime,\n        endTime: this.currentTime + 1\n      });\n      this.currentTime += 1;\n    }\n    this.notifyStateChange();\n    return this.getState();\n  }\n\n  /**\n   * Handle preemption of running process\n   * \n   * PREEMPTION SCENARIOS:\n   * ─────────────────────\n   * 1. Time quantum expired (Round Robin)\n   * 2. Higher priority process arrived (Priority Scheduling)\n   * 3. Shorter job arrived (Preemptive SJF)\n   */\n  handlePreemption() {\n    if (!this.runningProcess) return;\n    const process = this.runningProcess;\n\n    // In MLFQ, using full quantum = demotion\n    if (this.strategy.name === 'MLFQ' && this.quantumRemaining <= 0) {\n      process.demote(2); // Max 3 queues (0, 1, 2)\n    }\n\n    // Move back to ready queue\n    process.setState(ProcessState.READY, this.currentTime);\n    this.readyQueue.push(process);\n    this.runningProcess = null;\n  }\n\n  /**\n   * Check for processes that have arrived at current time\n   */\n  checkArrivals() {\n    for (const process of this.processes) {\n      if (process.state === ProcessState.NEW && process.arrivalTime <= this.currentTime) {\n        this.admitProcess(process);\n      }\n    }\n  }\n\n  /**\n   * Check for completed I/O operations\n   */\n  checkIOCompletions() {\n    const completedIO = [];\n    for (const process of this.waitingQueue) {\n      if (process.processIO(1)) {\n        completedIO.push(process);\n      }\n    }\n\n    // Move completed I/O processes back to ready queue\n    for (const process of completedIO) {\n      this.waitingQueue = this.waitingQueue.filter(p => p.id !== process.id);\n      process.setState(ProcessState.READY, this.currentTime);\n      this.readyQueue.push(process);\n    }\n  }\n\n  /**\n   * Run simulation until all processes complete\n   * \n   * @param {number} stepDelay - Delay between steps in ms (for visualization)\n   */\n  async run(stepDelay = 500) {\n    this.isRunning = true;\n    while (this.isRunning && !this.isComplete()) {\n      await this.step();\n      await this.delay(stepDelay);\n    }\n    this.isRunning = false;\n  }\n\n  /**\n   * Pause the simulation\n   */\n  pause() {\n    this.isRunning = false;\n  }\n\n  /**\n   * Check if all processes have completed\n   */\n  isComplete() {\n    return this.processes.length > 0 && this.processes.every(p => p.state === ProcessState.TERMINATED);\n  }\n\n  /**\n   * Reset the scheduler for a new simulation\n   */\n  reset() {\n    this.currentTime = 0;\n    this.isRunning = false;\n    this.isContextSwitching = false;\n    this.runningProcess = null;\n    this.readyQueue = [];\n    this.waitingQueue = [];\n    this.completedProcesses = [];\n    this.ganttChart = [];\n    this.quantumRemaining = 0;\n    this.metrics = {\n      totalIdleTime: 0,\n      totalContextSwitches: 0,\n      processesCompleted: 0\n    };\n\n    // Reset all processes\n    for (const process of this.processes) {\n      process.reset();\n    }\n\n    // Re-admit processes that have arrived at time 0\n    this.checkArrivals();\n    this.notifyStateChange();\n  }\n\n  /**\n   * Clear all processes\n   */\n  clear() {\n    this.processes = [];\n    this.reset();\n  }\n\n  /**\n   * Calculate comprehensive metrics\n   * \n   * @returns {Object} - Calculated metrics\n   */\n  calculateMetrics() {\n    const completed = this.processes.filter(p => p.state === ProcessState.TERMINATED);\n    if (completed.length === 0) {\n      return {\n        avgWaitingTime: 0,\n        avgTurnaroundTime: 0,\n        avgResponseTime: 0,\n        cpuUtilization: 0,\n        throughput: 0,\n        contextSwitches: this.metrics.totalContextSwitches\n      };\n    }\n\n    /**\n     * AVERAGE WAITING TIME\n     * ────────────────────\n     * Sum of all waiting times / Number of processes\n     * \n     * Lower is better - indicates less time spent idle in ready queue.\n     * FCFS can have very high waiting time due to Convoy Effect.\n     * SJF theoretically minimizes this metric.\n     */\n    const avgWaitingTime = completed.reduce((sum, p) => sum + p.waitingTime, 0) / completed.length;\n\n    /**\n     * AVERAGE TURNAROUND TIME\n     * ───────────────────────\n     * Sum of all turnaround times / Number of processes\n     * \n     * Turnaround = Completion - Arrival\n     * Lower is better - indicates faster job completion.\n     */\n    const avgTurnaroundTime = completed.reduce((sum, p) => sum + p.turnaroundTime, 0) / completed.length;\n\n    /**\n     * AVERAGE RESPONSE TIME\n     * ─────────────────────\n     * Sum of all response times / Number of processes\n     * \n     * Response = First Execution - Arrival\n     * Critical for interactive systems - users hate waiting!\n     */\n    const avgResponseTime = completed.reduce((sum, p) => sum + (p.responseTime || 0), 0) / completed.length;\n\n    /**\n     * CPU UTILIZATION\n     * ───────────────\n     * (Total Time - Idle Time) / Total Time * 100\n     * \n     * Higher is better - indicates CPU is being used efficiently.\n     * 100% utilization isn't always desirable (no headroom for spikes).\n     */\n    const totalTime = this.currentTime || 1;\n    const busyTime = totalTime - this.metrics.totalIdleTime - this.metrics.totalContextSwitches * this.contextSwitchOverhead;\n    const cpuUtilization = Math.max(0, busyTime / totalTime * 100);\n\n    /**\n     * THROUGHPUT\n     * ──────────\n     * Number of processes completed per unit time\n     * \n     * Higher is better - indicates system is completing work quickly.\n     */\n    const throughput = completed.length / (totalTime || 1);\n    return {\n      avgWaitingTime: avgWaitingTime.toFixed(2),\n      avgTurnaroundTime: avgTurnaroundTime.toFixed(2),\n      avgResponseTime: avgResponseTime.toFixed(2),\n      cpuUtilization: cpuUtilization.toFixed(1),\n      throughput: throughput.toFixed(3),\n      contextSwitches: this.metrics.totalContextSwitches\n    };\n  }\n\n  /**\n   * Get current scheduler state for UI\n   */\n  getState() {\n    return {\n      currentTime: this.currentTime,\n      isRunning: this.isRunning,\n      isContextSwitching: this.isContextSwitching,\n      runningProcess: this.runningProcess ? this.runningProcess.toSnapshot() : null,\n      readyQueue: this.readyQueue.map(p => p.toSnapshot()),\n      waitingQueue: this.waitingQueue.map(p => p.toSnapshot()),\n      completedProcesses: this.completedProcesses.map(p => p.toSnapshot()),\n      allProcesses: this.processes.map(p => p.toSnapshot()),\n      ganttChart: this.ganttChart,\n      metrics: this.calculateMetrics(),\n      strategy: this.strategy ? {\n        name: this.strategy.name,\n        description: this.strategy.description,\n        timeQuantum: this.strategy.timeQuantum\n      } : null,\n      quantumRemaining: this.quantumRemaining\n    };\n  }\n\n  /**\n   * Notify UI of state change\n   */\n  notifyStateChange() {\n    if (this.onStateChange) {\n      this.onStateChange(this.getState());\n    }\n  }\n\n  /**\n   * Utility function for delays\n   */\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\nexport default Scheduler;","map":{"version":3,"names":["ProcessState","Scheduler","constructor","strategy","processes","readyQueue","waitingQueue","runningProcess","completedProcesses","currentTime","isRunning","contextSwitchOverhead","isContextSwitching","ganttChart","metrics","totalIdleTime","totalContextSwitches","processesCompleted","onStateChange","onContextSwitch","onProcessComplete","quantumRemaining","setStrategy","timeQuantum","addProcess","process","push","arrivalTime","admitProcess","state","NEW","setState","READY","onProcessAdmit","killProcess","processId","filter","p","id","TERMINATED","find","notifyStateChange","injectIOInterrupt","ioDuration","WAITING","startIO","name","promote","performContextSwitch","nextProcess","from","toSnapshot","to","overhead","type","startTime","endTime","delay","step","Error","checkArrivals","checkIOCompletions","length","selectNext","RUNNING","Infinity","result","execute","processName","color","completed","requestsIO","Math","floor","random","shouldPreempt","handlePreemption","getState","demote","completedIO","processIO","run","stepDelay","isComplete","pause","every","reset","clear","calculateMetrics","avgWaitingTime","avgTurnaroundTime","avgResponseTime","cpuUtilization","throughput","contextSwitches","reduce","sum","waitingTime","turnaroundTime","responseTime","totalTime","busyTime","max","toFixed","map","allProcesses","description","ms","Promise","resolve","setTimeout"],"sources":["/Users/belalraza/Desktop/osPROJECT/src/core/Scheduler.js"],"sourcesContent":["/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║                          SCHEDULER CLASS                                   ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The Scheduler is the HEART of the operating system.                       ║\n * ║                                                                           ║\n * ║ It implements the STRATEGY DESIGN PATTERN, allowing different scheduling  ║\n * ║ algorithms to be plugged in dynamically without changing the core logic.  ║\n * ║                                                                           ║\n * ║ THE ILLUSION OF PARALLELISM                                               ║\n * ║ ─────────────────────────────                                             ║\n * ║ A single CPU can only execute ONE instruction at a time. Yet, users       ║\n * ║ perceive multiple programs running simultaneously. This \"illusion\" is     ║\n * ║ achieved through:                                                         ║\n * ║                                                                           ║\n * ║ 1. RAPID CONTEXT SWITCHING - The CPU switches between processes so fast   ║\n * ║    (thousands of times per second) that humans perceive simultaneity.     ║\n * ║                                                                           ║\n * ║ 2. TIME SLICING - Each process gets a small \"slice\" of CPU time before    ║\n * ║    the OS preempts it and gives another process a turn.                   ║\n * ║                                                                           ║\n * ║ 3. SMART SCHEDULING - The OS decides WHICH process runs next and for      ║\n * ║    HOW LONG, optimizing for various goals (fairness, throughput, etc.)    ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { ProcessState } from './Process';\n\n/**\n * ┌─────────────────────────────────────────────────────────────────────────────┐\n * │                     SCHEDULING GOALS & TRADE-OFFS                           │\n * ├─────────────────────────────────────────────────────────────────────────────┤\n * │                                                                             │\n * │  Different environments have different optimization goals:                  │\n * │                                                                             │\n * │  BATCH SYSTEMS (no human waiting):                                         │\n * │  ├─ Maximize THROUGHPUT (jobs completed per unit time)                     │\n * │  ├─ Minimize TURNAROUND TIME (arrival to completion)                       │\n * │  └─ Maximize CPU UTILIZATION (keep CPU busy)                               │\n * │                                                                             │\n * │  INTERACTIVE SYSTEMS (humans waiting):                                      │\n * │  ├─ Minimize RESPONSE TIME (time to first output)                          │\n * │  └─ Ensure FAIRNESS (no process starves)                                   │\n * │                                                                             │\n * │  REAL-TIME SYSTEMS (deadlines matter):                                      │\n * │  └─ Meet DEADLINES (absolute requirement)                                  │\n * │                                                                             │\n * │  ⚠️  These goals CONFLICT! Optimizing one often hurts another.             │\n * │      Example: High throughput may cause poor response time.                │\n * │                                                                             │\n * └─────────────────────────────────────────────────────────────────────────────┘\n */\n\n/**\n * Scheduler Class (Context in Strategy Pattern)\n * \n * Manages process scheduling and CPU time allocation.\n * The actual scheduling logic is delegated to a Strategy object.\n */\nexport class Scheduler {\n  /**\n   * Create a new Scheduler\n   * \n   * @param {SchedulingStrategy} strategy - The scheduling algorithm to use\n   */\n  constructor(strategy = null) {\n    // The currently selected scheduling strategy\n    this.strategy = strategy;\n    \n    // All processes in the system\n    this.processes = [];\n    \n    // Ready queue - processes waiting for CPU\n    this.readyQueue = [];\n    \n    // Waiting queue - processes blocked for I/O\n    this.waitingQueue = [];\n    \n    // Currently running process (only ONE in single-core simulation)\n    this.runningProcess = null;\n    \n    // Completed processes\n    this.completedProcesses = [];\n    \n    // Current simulation time (in arbitrary time units)\n    this.currentTime = 0;\n    \n    // Is simulation currently running?\n    this.isRunning = false;\n    \n    /**\n     * CONTEXT SWITCH OVERHEAD\n     * ───────────────────────\n     * In real systems, context switching has a COST:\n     * \n     * 1. Save state of current process (registers, program counter, etc.)\n     * 2. Update PCB (Process Control Block) of current process\n     * 3. Move PCB to appropriate queue\n     * 4. Select next process (scheduling algorithm runs)\n     * 5. Update PCB of new process\n     * 6. Restore state of new process\n     * 7. Flush TLB (Translation Lookaside Buffer) - very expensive!\n     * 8. Potentially reload cache lines - even more expensive!\n     * \n     * This typically takes 1-1000 microseconds depending on hardware.\n     * We simulate this with a configurable overhead value.\n     */\n    this.contextSwitchOverhead = 1; // Time units\n    \n    // Is context switch currently happening?\n    this.isContextSwitching = false;\n    \n    // Gantt chart data for visualization\n    this.ganttChart = [];\n    \n    // Metrics tracking\n    this.metrics = {\n      totalIdleTime: 0,\n      totalContextSwitches: 0,\n      processesCompleted: 0\n    };\n    \n    // Callbacks for UI updates\n    this.onStateChange = null;\n    this.onContextSwitch = null;\n    this.onProcessComplete = null;\n    \n    // Time quantum remaining (for Round Robin)\n    this.quantumRemaining = 0;\n  }\n  \n  /**\n   * Set the scheduling strategy (algorithm)\n   * \n   * This is the key to the Strategy Pattern - we can swap algorithms\n   * at runtime without changing any of the Scheduler's core logic.\n   * \n   * @param {SchedulingStrategy} strategy - The new scheduling strategy\n   */\n  setStrategy(strategy) {\n    this.strategy = strategy;\n    // Reset quantum when changing strategies\n    if (strategy && strategy.timeQuantum) {\n      this.quantumRemaining = strategy.timeQuantum;\n    }\n  }\n  \n  /**\n   * Add a process to the system\n   * \n   * @param {Process} process - The process to add\n   */\n  addProcess(process) {\n    this.processes.push(process);\n    \n    // If process has already arrived, add to ready queue\n    if (process.arrivalTime <= this.currentTime) {\n      this.admitProcess(process);\n    }\n  }\n  \n  /**\n   * Admit a process to the ready queue\n   * \n   * @param {Process} process - Process to admit\n   */\n  admitProcess(process) {\n    if (process.state === ProcessState.NEW) {\n      process.setState(ProcessState.READY, this.currentTime);\n      this.readyQueue.push(process);\n      \n      // Let strategy know about new process (for MLFQ queue assignment)\n      if (this.strategy && this.strategy.onProcessAdmit) {\n        this.strategy.onProcessAdmit(process);\n      }\n    }\n  }\n  \n  /**\n   * Remove a process from the system (kill)\n   * \n   * @param {string} processId - ID of process to kill\n   */\n  killProcess(processId) {\n    // Find and remove from all queues\n    this.readyQueue = this.readyQueue.filter(p => p.id !== processId);\n    this.waitingQueue = this.waitingQueue.filter(p => p.id !== processId);\n    \n    if (this.runningProcess && this.runningProcess.id === processId) {\n      this.runningProcess.setState(ProcessState.TERMINATED, this.currentTime);\n      this.runningProcess = null;\n    }\n    \n    // Find in processes array and terminate\n    const process = this.processes.find(p => p.id === processId);\n    if (process && process.state !== ProcessState.TERMINATED) {\n      process.setState(ProcessState.TERMINATED, this.currentTime);\n      this.completedProcesses.push(process);\n    }\n    \n    this.notifyStateChange();\n  }\n  \n  /**\n   * Inject an I/O interrupt to the running process\n   * \n   * This simulates a process requesting I/O (disk read, network, etc.)\n   * The process moves to WAITING state and another process can run.\n   * \n   * @param {number} ioDuration - How long the I/O takes\n   */\n  injectIOInterrupt(ioDuration = 5) {\n    if (this.runningProcess) {\n      const process = this.runningProcess;\n      process.setState(ProcessState.WAITING, this.currentTime);\n      process.startIO(ioDuration);\n      \n      // In MLFQ, yielding for I/O is rewarded with promotion\n      if (this.strategy && this.strategy.name === 'MLFQ') {\n        process.promote();\n      }\n      \n      this.waitingQueue.push(process);\n      this.runningProcess = null;\n      \n      this.notifyStateChange();\n    }\n  }\n  \n  /**\n   * Perform a context switch\n   * \n   * @param {Process} nextProcess - The process to switch to\n   * @returns {Promise} - Resolves when context switch is complete\n   */\n  async performContextSwitch(nextProcess) {\n    this.isContextSwitching = true;\n    this.metrics.totalContextSwitches++;\n    \n    // Notify UI about context switch starting\n    if (this.onContextSwitch) {\n      this.onContextSwitch({\n        from: this.runningProcess ? this.runningProcess.toSnapshot() : null,\n        to: nextProcess.toSnapshot(),\n        overhead: this.contextSwitchOverhead\n      });\n    }\n    \n    // Record context switch in Gantt chart\n    this.ganttChart.push({\n      type: 'context_switch',\n      startTime: this.currentTime,\n      endTime: this.currentTime + this.contextSwitchOverhead\n    });\n    \n    // Simulate context switch delay\n    await this.delay(this.contextSwitchOverhead * 100); // Visual delay\n    \n    this.currentTime += this.contextSwitchOverhead;\n    this.isContextSwitching = false;\n    \n    return true;\n  }\n  \n  /**\n   * Execute one simulation step\n   * \n   * This is the main scheduling loop iteration.\n   * \n   * @returns {Object} - Step result with state information\n   */\n  async step() {\n    if (!this.strategy) {\n      throw new Error('No scheduling strategy set!');\n    }\n    \n    // 1. Check for newly arriving processes\n    this.checkArrivals();\n    \n    // 2. Check for I/O completions\n    this.checkIOCompletions();\n    \n    // 3. If nothing is running, select next process\n    if (!this.runningProcess && this.readyQueue.length > 0) {\n      const nextProcess = this.strategy.selectNext(this.readyQueue, this.currentTime);\n      \n      if (nextProcess) {\n        // Remove from ready queue\n        this.readyQueue = this.readyQueue.filter(p => p.id !== nextProcess.id);\n        \n        // Perform context switch\n        await this.performContextSwitch(nextProcess);\n        \n        // Start running the process\n        this.runningProcess = nextProcess;\n        nextProcess.setState(ProcessState.RUNNING, this.currentTime);\n        \n        // Reset quantum for this process\n        this.quantumRemaining = this.strategy.timeQuantum || Infinity;\n      }\n    }\n    \n    // 4. Execute running process for one time unit\n    if (this.runningProcess) {\n      const result = this.runningProcess.execute(1);\n      \n      // Record in Gantt chart\n      this.ganttChart.push({\n        type: 'execution',\n        processId: this.runningProcess.id,\n        processName: this.runningProcess.name,\n        color: this.runningProcess.color,\n        startTime: this.currentTime,\n        endTime: this.currentTime + 1\n      });\n      \n      this.currentTime += 1;\n      this.quantumRemaining -= 1;\n      \n      // Check if process completed\n      if (result.completed) {\n        this.runningProcess.setState(ProcessState.TERMINATED, this.currentTime);\n        this.completedProcesses.push(this.runningProcess);\n        this.metrics.processesCompleted++;\n        \n        if (this.onProcessComplete) {\n          this.onProcessComplete(this.runningProcess.toSnapshot());\n        }\n        \n        this.runningProcess = null;\n      }\n      // Check if process requests I/O\n      else if (result.requestsIO) {\n        this.injectIOInterrupt(3 + Math.floor(Math.random() * 5));\n      }\n      // Check for preemption (quantum expired or higher priority arrived)\n      else if (this.strategy.shouldPreempt(this.runningProcess, this.readyQueue, this.quantumRemaining)) {\n        // Handle preemption based on strategy\n        this.handlePreemption();\n      }\n    } else {\n      // CPU is idle\n      this.metrics.totalIdleTime++;\n      this.ganttChart.push({\n        type: 'idle',\n        startTime: this.currentTime,\n        endTime: this.currentTime + 1\n      });\n      this.currentTime += 1;\n    }\n    \n    this.notifyStateChange();\n    \n    return this.getState();\n  }\n  \n  /**\n   * Handle preemption of running process\n   * \n   * PREEMPTION SCENARIOS:\n   * ─────────────────────\n   * 1. Time quantum expired (Round Robin)\n   * 2. Higher priority process arrived (Priority Scheduling)\n   * 3. Shorter job arrived (Preemptive SJF)\n   */\n  handlePreemption() {\n    if (!this.runningProcess) return;\n    \n    const process = this.runningProcess;\n    \n    // In MLFQ, using full quantum = demotion\n    if (this.strategy.name === 'MLFQ' && this.quantumRemaining <= 0) {\n      process.demote(2); // Max 3 queues (0, 1, 2)\n    }\n    \n    // Move back to ready queue\n    process.setState(ProcessState.READY, this.currentTime);\n    this.readyQueue.push(process);\n    this.runningProcess = null;\n  }\n  \n  /**\n   * Check for processes that have arrived at current time\n   */\n  checkArrivals() {\n    for (const process of this.processes) {\n      if (process.state === ProcessState.NEW && process.arrivalTime <= this.currentTime) {\n        this.admitProcess(process);\n      }\n    }\n  }\n  \n  /**\n   * Check for completed I/O operations\n   */\n  checkIOCompletions() {\n    const completedIO = [];\n    \n    for (const process of this.waitingQueue) {\n      if (process.processIO(1)) {\n        completedIO.push(process);\n      }\n    }\n    \n    // Move completed I/O processes back to ready queue\n    for (const process of completedIO) {\n      this.waitingQueue = this.waitingQueue.filter(p => p.id !== process.id);\n      process.setState(ProcessState.READY, this.currentTime);\n      this.readyQueue.push(process);\n    }\n  }\n  \n  /**\n   * Run simulation until all processes complete\n   * \n   * @param {number} stepDelay - Delay between steps in ms (for visualization)\n   */\n  async run(stepDelay = 500) {\n    this.isRunning = true;\n    \n    while (this.isRunning && !this.isComplete()) {\n      await this.step();\n      await this.delay(stepDelay);\n    }\n    \n    this.isRunning = false;\n  }\n  \n  /**\n   * Pause the simulation\n   */\n  pause() {\n    this.isRunning = false;\n  }\n  \n  /**\n   * Check if all processes have completed\n   */\n  isComplete() {\n    return this.processes.length > 0 && \n           this.processes.every(p => p.state === ProcessState.TERMINATED);\n  }\n  \n  /**\n   * Reset the scheduler for a new simulation\n   */\n  reset() {\n    this.currentTime = 0;\n    this.isRunning = false;\n    this.isContextSwitching = false;\n    this.runningProcess = null;\n    this.readyQueue = [];\n    this.waitingQueue = [];\n    this.completedProcesses = [];\n    this.ganttChart = [];\n    this.quantumRemaining = 0;\n    \n    this.metrics = {\n      totalIdleTime: 0,\n      totalContextSwitches: 0,\n      processesCompleted: 0\n    };\n    \n    // Reset all processes\n    for (const process of this.processes) {\n      process.reset();\n    }\n    \n    // Re-admit processes that have arrived at time 0\n    this.checkArrivals();\n    \n    this.notifyStateChange();\n  }\n  \n  /**\n   * Clear all processes\n   */\n  clear() {\n    this.processes = [];\n    this.reset();\n  }\n  \n  /**\n   * Calculate comprehensive metrics\n   * \n   * @returns {Object} - Calculated metrics\n   */\n  calculateMetrics() {\n    const completed = this.processes.filter(p => p.state === ProcessState.TERMINATED);\n    \n    if (completed.length === 0) {\n      return {\n        avgWaitingTime: 0,\n        avgTurnaroundTime: 0,\n        avgResponseTime: 0,\n        cpuUtilization: 0,\n        throughput: 0,\n        contextSwitches: this.metrics.totalContextSwitches\n      };\n    }\n    \n    /**\n     * AVERAGE WAITING TIME\n     * ────────────────────\n     * Sum of all waiting times / Number of processes\n     * \n     * Lower is better - indicates less time spent idle in ready queue.\n     * FCFS can have very high waiting time due to Convoy Effect.\n     * SJF theoretically minimizes this metric.\n     */\n    const avgWaitingTime = completed.reduce((sum, p) => sum + p.waitingTime, 0) / completed.length;\n    \n    /**\n     * AVERAGE TURNAROUND TIME\n     * ───────────────────────\n     * Sum of all turnaround times / Number of processes\n     * \n     * Turnaround = Completion - Arrival\n     * Lower is better - indicates faster job completion.\n     */\n    const avgTurnaroundTime = completed.reduce((sum, p) => sum + p.turnaroundTime, 0) / completed.length;\n    \n    /**\n     * AVERAGE RESPONSE TIME\n     * ─────────────────────\n     * Sum of all response times / Number of processes\n     * \n     * Response = First Execution - Arrival\n     * Critical for interactive systems - users hate waiting!\n     */\n    const avgResponseTime = completed.reduce((sum, p) => sum + (p.responseTime || 0), 0) / completed.length;\n    \n    /**\n     * CPU UTILIZATION\n     * ───────────────\n     * (Total Time - Idle Time) / Total Time * 100\n     * \n     * Higher is better - indicates CPU is being used efficiently.\n     * 100% utilization isn't always desirable (no headroom for spikes).\n     */\n    const totalTime = this.currentTime || 1;\n    const busyTime = totalTime - this.metrics.totalIdleTime - \n                     (this.metrics.totalContextSwitches * this.contextSwitchOverhead);\n    const cpuUtilization = Math.max(0, (busyTime / totalTime) * 100);\n    \n    /**\n     * THROUGHPUT\n     * ──────────\n     * Number of processes completed per unit time\n     * \n     * Higher is better - indicates system is completing work quickly.\n     */\n    const throughput = completed.length / (totalTime || 1);\n    \n    return {\n      avgWaitingTime: avgWaitingTime.toFixed(2),\n      avgTurnaroundTime: avgTurnaroundTime.toFixed(2),\n      avgResponseTime: avgResponseTime.toFixed(2),\n      cpuUtilization: cpuUtilization.toFixed(1),\n      throughput: throughput.toFixed(3),\n      contextSwitches: this.metrics.totalContextSwitches\n    };\n  }\n  \n  /**\n   * Get current scheduler state for UI\n   */\n  getState() {\n    return {\n      currentTime: this.currentTime,\n      isRunning: this.isRunning,\n      isContextSwitching: this.isContextSwitching,\n      runningProcess: this.runningProcess ? this.runningProcess.toSnapshot() : null,\n      readyQueue: this.readyQueue.map(p => p.toSnapshot()),\n      waitingQueue: this.waitingQueue.map(p => p.toSnapshot()),\n      completedProcesses: this.completedProcesses.map(p => p.toSnapshot()),\n      allProcesses: this.processes.map(p => p.toSnapshot()),\n      ganttChart: this.ganttChart,\n      metrics: this.calculateMetrics(),\n      strategy: this.strategy ? {\n        name: this.strategy.name,\n        description: this.strategy.description,\n        timeQuantum: this.strategy.timeQuantum\n      } : null,\n      quantumRemaining: this.quantumRemaining\n    };\n  }\n  \n  /**\n   * Notify UI of state change\n   */\n  notifyStateChange() {\n    if (this.onStateChange) {\n      this.onStateChange(this.getState());\n    }\n  }\n  \n  /**\n   * Utility function for delays\n   */\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\nexport default Scheduler;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,YAAY,QAAQ,WAAW;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS,CAAC;EACrB;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAACC,QAAQ,GAAG,IAAI,EAAE;IAC3B;IACA,IAAI,CAACA,QAAQ,GAAGA,QAAQ;;IAExB;IACA,IAAI,CAACC,SAAS,GAAG,EAAE;;IAEnB;IACA,IAAI,CAACC,UAAU,GAAG,EAAE;;IAEpB;IACA,IAAI,CAACC,YAAY,GAAG,EAAE;;IAEtB;IACA,IAAI,CAACC,cAAc,GAAG,IAAI;;IAE1B;IACA,IAAI,CAACC,kBAAkB,GAAG,EAAE;;IAE5B;IACA,IAAI,CAACC,WAAW,GAAG,CAAC;;IAEpB;IACA,IAAI,CAACC,SAAS,GAAG,KAAK;;IAEtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,qBAAqB,GAAG,CAAC,CAAC,CAAC;;IAEhC;IACA,IAAI,CAACC,kBAAkB,GAAG,KAAK;;IAE/B;IACA,IAAI,CAACC,UAAU,GAAG,EAAE;;IAEpB;IACA,IAAI,CAACC,OAAO,GAAG;MACbC,aAAa,EAAE,CAAC;MAChBC,oBAAoB,EAAE,CAAC;MACvBC,kBAAkB,EAAE;IACtB,CAAC;;IAED;IACA,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,iBAAiB,GAAG,IAAI;;IAE7B;IACA,IAAI,CAACC,gBAAgB,GAAG,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;AAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}