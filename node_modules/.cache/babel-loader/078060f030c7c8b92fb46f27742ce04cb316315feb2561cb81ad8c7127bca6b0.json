{"ast":null,"code":"/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║              SHORTEST JOB FIRST (SJF) STRATEGY                            ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ Schedule the process with the shortest remaining burst time first.        ║\n * ║ Provably OPTIMAL for minimizing average waiting time.                     ║\n * ║                                                                           ║\n * ║ CHARACTERISTICS:                                                          ║\n * ║ ────────────────                                                          ║\n * ║ ✓ Optimal average waiting time (mathematical proof exists!)              ║\n * ║ ✓ Good throughput                                                        ║\n * ║ ✗ REQUIRES KNOWING BURST TIME IN ADVANCE (impractical in reality)        ║\n * ║ ✗ Can cause STARVATION of long processes                                 ║\n * ║ ✗ Not suitable for interactive systems                                   ║\n * ║                                                                           ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐   ║\n * ║ │                          STARVATION                                 │   ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤   ║\n * ║ │                                                                     │   ║\n * ║ │  Starvation occurs when a process waits indefinitely because        │   ║\n * ║ │  other processes keep \"cutting in line.\"                            │   ║\n * ║ │                                                                     │   ║\n * ║ │  In SJF:                                                            │   ║\n * ║ │  - If short jobs keep arriving, long jobs may NEVER run             │   ║\n * ║ │  - A job with burst time 100 could wait forever if jobs with        │   ║\n * ║ │    burst time 1-10 keep arriving                                    │   ║\n * ║ │                                                                     │   ║\n * ║ │  SOLUTION: AGING                                                    │   ║\n * ║ │  ─────────────────                                                  │   ║\n * ║ │  Gradually increase the priority of waiting processes.              │   ║\n * ║ │  Eventually, even long jobs become \"high priority\" through aging.   │   ║\n * ║ │                                                                     │   ║\n * ║ └─────────────────────────────────────────────────────────────────────┘   ║\n * ║                                                                           ║\n * ║ VARIANTS:                                                                 ║\n * ║ ─────────                                                                 ║\n * ║ 1. Non-preemptive SJF: Once started, process runs to completion          ║\n * ║ 2. Preemptive SJF (SRTF): If shorter job arrives, preempt current        ║\n * ║                                                                           ║\n * ║ This implementation supports BOTH modes via a configuration option.       ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { SchedulingStrategy } from './SchedulingStrategy';\nexport class SJFStrategy extends SchedulingStrategy {\n  /**\n   * Create SJF Strategy\n   * \n   * @param {boolean} preemptive - If true, use Shortest Remaining Time First (SRTF)\n   */\n  constructor(preemptive = false) {\n    super();\n    this.isPreemptive = preemptive;\n    this.name = preemptive ? 'SRTF' : 'SJF';\n    this.description = preemptive ? `Shortest Remaining Time First: Preemptive version of SJF. \nIf a new process arrives with shorter remaining time than the running process, \npreempt immediately. Optimal but can cause STARVATION of long processes.` : `Shortest Job First: Select the process with smallest burst time. \nProvably OPTIMAL for average waiting time, but requires knowing burst times \nin advance. Can cause STARVATION - long processes may never run!`;\n    this.timeQuantum = null; // No fixed quantum, but may preempt for shorter job\n  }\n\n  /**\n   * Select the process with shortest (remaining) burst time\n   * \n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - Process with shortest remaining time\n   */\n  selectNext(readyQueue, currentTime) {\n    if (readyQueue.length === 0) {\n      return null;\n    }\n\n    /**\n     * SJF Selection Logic:\n     * ────────────────────\n     * Find the process with the SHORTEST remaining burst time.\n     * \n     * For non-preemptive SJF, we look at original burst time\n     * (since we're selecting before any execution happens).\n     * \n     * For preemptive SRTF, we look at remaining time\n     * (since the process may have already partially executed).\n     * \n     * We use remainingTime in both cases for simplicity,\n     * as remainingTime == burstTime for processes that haven't started.\n     * \n     * TIE-BREAKER: If two processes have same remaining time,\n     * prefer the one that arrived earlier (FCFS for ties).\n     */\n\n    const sorted = [...readyQueue].sort((a, b) => {\n      // Primary sort: remaining time (ascending)\n      if (a.remainingTime !== b.remainingTime) {\n        return a.remainingTime - b.remainingTime;\n      }\n      // Secondary sort: arrival time (ascending) - FCFS tie-breaker\n      return a.arrivalTime - b.arrivalTime;\n    });\n    return sorted[0];\n  }\n\n  /**\n   * Check if running process should be preempted\n   * \n   * For SRTF: preempt if a process in ready queue has shorter remaining time\n   * For non-preemptive SJF: never preempt\n   * \n   * @param {Process} runningProcess - Currently running process\n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} quantumRemaining - Not used for SJF\n   * @returns {boolean} - True if should preempt\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    // Non-preemptive SJF never preempts\n    if (!this.isPreemptive) {\n      return false;\n    }\n\n    // SRTF: Check if any waiting process has shorter remaining time\n    if (readyQueue.length === 0) {\n      return false;\n    }\n\n    // Find shortest job in ready queue\n    const shortestWaiting = Math.min(...readyQueue.map(p => p.remainingTime));\n\n    /**\n     * PREEMPTION DECISION:\n     * ────────────────────\n     * Only preempt if waiting process has STRICTLY shorter remaining time.\n     * If equal, keep running current process (don't incur context switch overhead).\n     */\n    return shortestWaiting < runningProcess.remainingTime;\n  }\n}\nexport default SJFStrategy;","map":{"version":3,"names":["SchedulingStrategy","SJFStrategy","constructor","preemptive","isPreemptive","name","description","timeQuantum","selectNext","readyQueue","currentTime","length","sorted","sort","a","b","remainingTime","arrivalTime","shouldPreempt","runningProcess","quantumRemaining","shortestWaiting","Math","min","map","p"],"sources":["/Users/belalraza/Desktop/osPROJECT/src/core/strategies/SJFStrategy.js"],"sourcesContent":["/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║              SHORTEST JOB FIRST (SJF) STRATEGY                            ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ Schedule the process with the shortest remaining burst time first.        ║\n * ║ Provably OPTIMAL for minimizing average waiting time.                     ║\n * ║                                                                           ║\n * ║ CHARACTERISTICS:                                                          ║\n * ║ ────────────────                                                          ║\n * ║ ✓ Optimal average waiting time (mathematical proof exists!)              ║\n * ║ ✓ Good throughput                                                        ║\n * ║ ✗ REQUIRES KNOWING BURST TIME IN ADVANCE (impractical in reality)        ║\n * ║ ✗ Can cause STARVATION of long processes                                 ║\n * ║ ✗ Not suitable for interactive systems                                   ║\n * ║                                                                           ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐   ║\n * ║ │                          STARVATION                                 │   ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤   ║\n * ║ │                                                                     │   ║\n * ║ │  Starvation occurs when a process waits indefinitely because        │   ║\n * ║ │  other processes keep \"cutting in line.\"                            │   ║\n * ║ │                                                                     │   ║\n * ║ │  In SJF:                                                            │   ║\n * ║ │  - If short jobs keep arriving, long jobs may NEVER run             │   ║\n * ║ │  - A job with burst time 100 could wait forever if jobs with        │   ║\n * ║ │    burst time 1-10 keep arriving                                    │   ║\n * ║ │                                                                     │   ║\n * ║ │  SOLUTION: AGING                                                    │   ║\n * ║ │  ─────────────────                                                  │   ║\n * ║ │  Gradually increase the priority of waiting processes.              │   ║\n * ║ │  Eventually, even long jobs become \"high priority\" through aging.   │   ║\n * ║ │                                                                     │   ║\n * ║ └─────────────────────────────────────────────────────────────────────┘   ║\n * ║                                                                           ║\n * ║ VARIANTS:                                                                 ║\n * ║ ─────────                                                                 ║\n * ║ 1. Non-preemptive SJF: Once started, process runs to completion          ║\n * ║ 2. Preemptive SJF (SRTF): If shorter job arrives, preempt current        ║\n * ║                                                                           ║\n * ║ This implementation supports BOTH modes via a configuration option.       ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { SchedulingStrategy } from './SchedulingStrategy';\n\nexport class SJFStrategy extends SchedulingStrategy {\n  /**\n   * Create SJF Strategy\n   * \n   * @param {boolean} preemptive - If true, use Shortest Remaining Time First (SRTF)\n   */\n  constructor(preemptive = false) {\n    super();\n    \n    this.isPreemptive = preemptive;\n    \n    this.name = preemptive ? 'SRTF' : 'SJF';\n    this.description = preemptive\n      ? `Shortest Remaining Time First: Preemptive version of SJF. \nIf a new process arrives with shorter remaining time than the running process, \npreempt immediately. Optimal but can cause STARVATION of long processes.`\n      : `Shortest Job First: Select the process with smallest burst time. \nProvably OPTIMAL for average waiting time, but requires knowing burst times \nin advance. Can cause STARVATION - long processes may never run!`;\n    \n    this.timeQuantum = null; // No fixed quantum, but may preempt for shorter job\n  }\n  \n  /**\n   * Select the process with shortest (remaining) burst time\n   * \n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - Process with shortest remaining time\n   */\n  selectNext(readyQueue, currentTime) {\n    if (readyQueue.length === 0) {\n      return null;\n    }\n    \n    /**\n     * SJF Selection Logic:\n     * ────────────────────\n     * Find the process with the SHORTEST remaining burst time.\n     * \n     * For non-preemptive SJF, we look at original burst time\n     * (since we're selecting before any execution happens).\n     * \n     * For preemptive SRTF, we look at remaining time\n     * (since the process may have already partially executed).\n     * \n     * We use remainingTime in both cases for simplicity,\n     * as remainingTime == burstTime for processes that haven't started.\n     * \n     * TIE-BREAKER: If two processes have same remaining time,\n     * prefer the one that arrived earlier (FCFS for ties).\n     */\n    \n    const sorted = [...readyQueue].sort((a, b) => {\n      // Primary sort: remaining time (ascending)\n      if (a.remainingTime !== b.remainingTime) {\n        return a.remainingTime - b.remainingTime;\n      }\n      // Secondary sort: arrival time (ascending) - FCFS tie-breaker\n      return a.arrivalTime - b.arrivalTime;\n    });\n    \n    return sorted[0];\n  }\n  \n  /**\n   * Check if running process should be preempted\n   * \n   * For SRTF: preempt if a process in ready queue has shorter remaining time\n   * For non-preemptive SJF: never preempt\n   * \n   * @param {Process} runningProcess - Currently running process\n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} quantumRemaining - Not used for SJF\n   * @returns {boolean} - True if should preempt\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    // Non-preemptive SJF never preempts\n    if (!this.isPreemptive) {\n      return false;\n    }\n    \n    // SRTF: Check if any waiting process has shorter remaining time\n    if (readyQueue.length === 0) {\n      return false;\n    }\n    \n    // Find shortest job in ready queue\n    const shortestWaiting = Math.min(...readyQueue.map(p => p.remainingTime));\n    \n    /**\n     * PREEMPTION DECISION:\n     * ────────────────────\n     * Only preempt if waiting process has STRICTLY shorter remaining time.\n     * If equal, keep running current process (don't incur context switch overhead).\n     */\n    return shortestWaiting < runningProcess.remainingTime;\n  }\n}\n\nexport default SJFStrategy;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,kBAAkB,QAAQ,sBAAsB;AAEzD,OAAO,MAAMC,WAAW,SAASD,kBAAkB,CAAC;EAClD;AACF;AACA;AACA;AACA;EACEE,WAAWA,CAACC,UAAU,GAAG,KAAK,EAAE;IAC9B,KAAK,CAAC,CAAC;IAEP,IAAI,CAACC,YAAY,GAAGD,UAAU;IAE9B,IAAI,CAACE,IAAI,GAAGF,UAAU,GAAG,MAAM,GAAG,KAAK;IACvC,IAAI,CAACG,WAAW,GAAGH,UAAU,GACzB;AACR;AACA,yEAAyE,GACjE;AACR;AACA,iEAAiE;IAE7D,IAAI,CAACI,WAAW,GAAG,IAAI,CAAC,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAACC,UAAU,EAAEC,WAAW,EAAE;IAClC,IAAID,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;MAC3B,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEI,MAAMC,MAAM,GAAG,CAAC,GAAGH,UAAU,CAAC,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MAC5C;MACA,IAAID,CAAC,CAACE,aAAa,KAAKD,CAAC,CAACC,aAAa,EAAE;QACvC,OAAOF,CAAC,CAACE,aAAa,GAAGD,CAAC,CAACC,aAAa;MAC1C;MACA;MACA,OAAOF,CAAC,CAACG,WAAW,GAAGF,CAAC,CAACE,WAAW;IACtC,CAAC,CAAC;IAEF,OAAOL,MAAM,CAAC,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,aAAaA,CAACC,cAAc,EAAEV,UAAU,EAAEW,gBAAgB,EAAE;IAC1D;IACA,IAAI,CAAC,IAAI,CAAChB,YAAY,EAAE;MACtB,OAAO,KAAK;IACd;;IAEA;IACA,IAAIK,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;MAC3B,OAAO,KAAK;IACd;;IAEA;IACA,MAAMU,eAAe,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAGd,UAAU,CAACe,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACT,aAAa,CAAC,CAAC;;IAEzE;AACJ;AACA;AACA;AACA;AACA;IACI,OAAOK,eAAe,GAAGF,cAAc,CAACH,aAAa;EACvD;AACF;AAEA,eAAef,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}