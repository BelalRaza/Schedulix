{"ast":null,"code":"/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║           MULTI-LEVEL FEEDBACK QUEUE (MLFQ) STRATEGY                      ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The most sophisticated and realistic scheduling algorithm.                 ║\n * ║ Used by modern operating systems (Windows, macOS, Linux variants).        ║\n * ║                                                                           ║\n * ║ MLFQ learns from process BEHAVIOR to make scheduling decisions!           ║\n * ║                                                                           ║\n * ║ KEY INSIGHT:                                                              ║\n * ║ ────────────                                                              ║\n * ║ We can't know burst times in advance, but we can OBSERVE behavior:        ║\n * ║ - Processes that USE their full quantum are likely CPU-BOUND              ║\n * ║ - Processes that YIELD early (for I/O) are likely I/O-BOUND               ║\n * ║                                                                           ║\n * ║ CHARACTERISTICS:                                                          ║\n * ║ ────────────────                                                          ║\n * ║ ✓ Adapts to process behavior automatically                               ║\n * ║ ✓ Favors interactive (I/O-bound) processes                               ║\n * ║ ✓ No advance knowledge of burst times needed                             ║\n * ║ ✓ Good response time for interactive tasks                               ║\n * ║ ✗ More complex to implement                                              ║\n * ║ ✗ Can be gamed by malicious processes                                    ║\n * ║ ✗ Requires tuning of many parameters                                     ║\n * ║                                                                           ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐   ║\n * ║ │                    MLFQ RULES                                       │   ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 1: If Priority(A) > Priority(B), A runs (B doesn't)          │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 2: If Priority(A) = Priority(B), A & B run in Round Robin    │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 3: New processes start at TOP priority                       │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 4a: If process uses entire quantum, DEMOTE to lower queue    │   ║\n * ║ │           (Penalize CPU-bound behavior)                            │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 4b: If process yields before quantum, STAY at same level     │   ║\n * ║ │           (Reward I/O-bound behavior)                              │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 5: Periodically BOOST all processes to top queue             │   ║\n * ║ │          (Prevents starvation of CPU-bound processes)              │   ║\n * ║ │                                                                     │   ║\n * ║ └─────────────────────────────────────────────────────────────────────┘   ║\n * ║                                                                           ║\n * ║ QUEUE STRUCTURE:                                                          ║\n * ║ ────────────────                                                          ║\n * ║                                                                           ║\n * ║   QUEUE 0 (Highest Priority) ─ Quantum: 4  ─ Interactive processes       ║\n * ║         │                                                                 ║\n * ║         │ DEMOTE (used full quantum)                                     ║\n * ║         ▼                                                                 ║\n * ║   QUEUE 1 (Medium Priority)  ─ Quantum: 8  ─ Mixed behavior              ║\n * ║         │                                                                 ║\n * ║         │ DEMOTE (used full quantum)                                     ║\n * ║         ▼                                                                 ║\n * ║   QUEUE 2 (Lowest Priority)  ─ Quantum: 16 ─ CPU-bound processes         ║\n * ║                                                                           ║\n * ║   Note: Lower queues have LARGER quantums - if you're CPU-bound,         ║\n * ║   might as well let you run longer per turn (fewer context switches).    ║\n * ║                                                                           ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { SchedulingStrategy } from './SchedulingStrategy';\nexport class MLFQStrategy extends SchedulingStrategy {\n  /**\n   * Create MLFQ Strategy\n   * \n   * @param {number} numQueues - Number of priority queues (default: 3)\n   * @param {number[]} quantums - Time quantum for each queue level\n   * @param {number} boostInterval - Time between priority boosts (to prevent starvation)\n   */\n  constructor(numQueues = 3, quantums = [4, 8, 16], boostInterval = 50) {\n    super();\n    this.name = 'MLFQ';\n    this.description = `Multi-Level Feedback Queue: The most sophisticated scheduler. \nProcesses start at highest priority. If they use full quantum, they're DEMOTED (CPU-bound penalty). \nIf they yield for I/O, they may be PROMOTED (I/O-bound reward). \nWatch processes move between the 3 priority queues based on their behavior!`;\n\n    // MLFQ is PREEMPTIVE\n    this.isPreemptive = true;\n\n    // Number of priority levels\n    this.numQueues = numQueues;\n\n    /**\n     * TIME QUANTUM PER LEVEL\n     * ──────────────────────\n     * Higher priority queues get SMALLER quantums:\n     * - Quick response for interactive processes\n     * - They don't need long bursts anyway\n     * \n     * Lower priority queues get LARGER quantums:\n     * - CPU-bound processes can make progress\n     * - Fewer context switches for long computations\n     */\n    this.quantums = quantums;\n\n    // Default time quantum (will be overridden based on queue level)\n    this.timeQuantum = quantums[0];\n\n    /**\n     * PRIORITY BOOST INTERVAL\n     * ───────────────────────\n     * Periodically boost all processes to top queue.\n     * This prevents STARVATION of CPU-bound processes.\n     * \n     * Without this, a CPU-bound process could be stuck in the\n     * lowest queue forever if interactive processes keep arriving.\n     */\n    this.boostInterval = boostInterval;\n    this.timeSinceLastBoost = 0;\n  }\n\n  /**\n   * Initialize a new process - assign to highest priority queue\n   * \n   * MLFQ RULE 3: New processes enter at top priority\n   * This gives new processes a chance to show they're interactive.\n   * \n   * @param {Process} process - Newly admitted process\n   */\n  onProcessAdmit(process) {\n    process.queueLevel = 0; // Start at highest priority\n    process.quantumUsed = 0; // Reset quantum tracking\n  }\n\n  /**\n   * Get time quantum for a process based on its queue level\n   * \n   * @param {Process} process - The process\n   * @returns {number} - Time quantum for this process\n   */\n  getQuantum(process) {\n    const level = process.queueLevel || 0;\n    return this.quantums[Math.min(level, this.quantums.length - 1)];\n  }\n\n  /**\n   * Select next process using MLFQ rules\n   * \n   * @param {Process[]} readyQueue - All waiting processes\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - Highest priority process to run\n   */\n  selectNext(readyQueue, currentTime) {\n    if (readyQueue.length === 0) {\n      return null;\n    }\n\n    /**\n     * MLFQ SELECTION ALGORITHM:\n     * ─────────────────────────\n     * 1. Check each queue from highest priority (0) to lowest\n     * 2. Return first process found in non-empty queue\n     * 3. Within same queue, use Round Robin (FIFO)\n     * \n     * RULE 1 & 2 in action:\n     * - Higher priority always runs first (Rule 1)\n     * - Same priority uses Round Robin (Rule 2)\n     */\n\n    // Group processes by queue level\n    const queues = Array.from({\n      length: this.numQueues\n    }, () => []);\n    for (const process of readyQueue) {\n      const level = Math.min(process.queueLevel || 0, this.numQueues - 1);\n      queues[level].push(process);\n    }\n\n    // Find highest priority non-empty queue\n    for (let level = 0; level < this.numQueues; level++) {\n      if (queues[level].length > 0) {\n        // Within queue, sort by arrival time (FIFO for Round Robin)\n        queues[level].sort((a, b) => a.arrivalTime - b.arrivalTime);\n\n        // Update timeQuantum to match selected process's queue\n        this.timeQuantum = this.quantums[level];\n        return queues[level][0];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Check if running process should be preempted\n   * \n   * Preempt if:\n   * 1. Quantum expired for current queue level\n   * 2. Higher priority process arrived\n   * \n   * @param {Process} runningProcess - Currently running process\n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} quantumRemaining - Time remaining in current quantum\n   * @returns {boolean} - True if should preempt\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    // Check if quantum expired (Rule 4a trigger)\n    if (quantumRemaining <= 0) {\n      return true;\n    }\n\n    // Check if higher priority process is waiting (Rule 1)\n    const runningLevel = runningProcess.queueLevel || 0;\n    const higherPriorityWaiting = readyQueue.some(p => (p.queueLevel || 0) < runningLevel);\n\n    /**\n     * PREEMPTION FOR HIGHER PRIORITY:\n     * ────────────────────────────────\n     * If a process in a higher priority queue is waiting,\n     * preempt the current process to run it.\n     * \n     * This ensures interactive processes get quick response time.\n     */\n    return higherPriorityWaiting;\n  }\n\n  /**\n   * Perform periodic priority boost (Rule 5)\n   * \n   * @param {Process[]} allProcesses - All processes in system\n   */\n  performBoost(allProcesses) {\n    this.timeSinceLastBoost = 0;\n    for (const process of allProcesses) {\n      process.queueLevel = 0;\n      process.quantumUsed = 0;\n    }\n  }\n\n  /**\n   * Check if boost is due\n   * \n   * @returns {boolean} - True if boost should happen\n   */\n  isBoostDue() {\n    return this.timeSinceLastBoost >= this.boostInterval;\n  }\n\n  /**\n   * Update time tracking for boost\n   * \n   * @param {number} elapsed - Time elapsed\n   */\n  updateTime(elapsed) {\n    this.timeSinceLastBoost += elapsed;\n  }\n\n  /**\n   * Get visual representation of queue structure for UI\n   * \n   * @param {Process[]} readyQueue - All waiting processes\n   * @returns {Object[]} - Queue structure with processes\n   */\n  getQueueStructure(readyQueue) {\n    const structure = [];\n    for (let level = 0; level < this.numQueues; level++) {\n      const processesInQueue = readyQueue.filter(p => (p.queueLevel || 0) === level);\n      structure.push({\n        level,\n        quantum: this.quantums[level],\n        priority: level === 0 ? 'Highest' : level === this.numQueues - 1 ? 'Lowest' : 'Medium',\n        processes: processesInQueue.map(p => p.toSnapshot()),\n        label: `Queue ${level} (Q=${this.quantums[level]})`\n      });\n    }\n    return structure;\n  }\n}\nexport default MLFQStrategy;","map":{"version":3,"names":["SchedulingStrategy","MLFQStrategy","constructor","numQueues","quantums","boostInterval","name","description","isPreemptive","timeQuantum","timeSinceLastBoost","onProcessAdmit","process","queueLevel","quantumUsed","getQuantum","level","Math","min","length","selectNext","readyQueue","currentTime","queues","Array","from","push","sort","a","b","arrivalTime","shouldPreempt","runningProcess","quantumRemaining","runningLevel","higherPriorityWaiting","some","p","performBoost","allProcesses","isBoostDue","updateTime","elapsed","getQueueStructure","structure","processesInQueue","filter","quantum","priority","processes","map","toSnapshot","label"],"sources":["/Users/belalraza/Desktop/osPROJECT/src/core/strategies/MLFQStrategy.js"],"sourcesContent":["/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║           MULTI-LEVEL FEEDBACK QUEUE (MLFQ) STRATEGY                      ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The most sophisticated and realistic scheduling algorithm.                 ║\n * ║ Used by modern operating systems (Windows, macOS, Linux variants).        ║\n * ║                                                                           ║\n * ║ MLFQ learns from process BEHAVIOR to make scheduling decisions!           ║\n * ║                                                                           ║\n * ║ KEY INSIGHT:                                                              ║\n * ║ ────────────                                                              ║\n * ║ We can't know burst times in advance, but we can OBSERVE behavior:        ║\n * ║ - Processes that USE their full quantum are likely CPU-BOUND              ║\n * ║ - Processes that YIELD early (for I/O) are likely I/O-BOUND               ║\n * ║                                                                           ║\n * ║ CHARACTERISTICS:                                                          ║\n * ║ ────────────────                                                          ║\n * ║ ✓ Adapts to process behavior automatically                               ║\n * ║ ✓ Favors interactive (I/O-bound) processes                               ║\n * ║ ✓ No advance knowledge of burst times needed                             ║\n * ║ ✓ Good response time for interactive tasks                               ║\n * ║ ✗ More complex to implement                                              ║\n * ║ ✗ Can be gamed by malicious processes                                    ║\n * ║ ✗ Requires tuning of many parameters                                     ║\n * ║                                                                           ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐   ║\n * ║ │                    MLFQ RULES                                       │   ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 1: If Priority(A) > Priority(B), A runs (B doesn't)          │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 2: If Priority(A) = Priority(B), A & B run in Round Robin    │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 3: New processes start at TOP priority                       │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 4a: If process uses entire quantum, DEMOTE to lower queue    │   ║\n * ║ │           (Penalize CPU-bound behavior)                            │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 4b: If process yields before quantum, STAY at same level     │   ║\n * ║ │           (Reward I/O-bound behavior)                              │   ║\n * ║ │                                                                     │   ║\n * ║ │  RULE 5: Periodically BOOST all processes to top queue             │   ║\n * ║ │          (Prevents starvation of CPU-bound processes)              │   ║\n * ║ │                                                                     │   ║\n * ║ └─────────────────────────────────────────────────────────────────────┘   ║\n * ║                                                                           ║\n * ║ QUEUE STRUCTURE:                                                          ║\n * ║ ────────────────                                                          ║\n * ║                                                                           ║\n * ║   QUEUE 0 (Highest Priority) ─ Quantum: 4  ─ Interactive processes       ║\n * ║         │                                                                 ║\n * ║         │ DEMOTE (used full quantum)                                     ║\n * ║         ▼                                                                 ║\n * ║   QUEUE 1 (Medium Priority)  ─ Quantum: 8  ─ Mixed behavior              ║\n * ║         │                                                                 ║\n * ║         │ DEMOTE (used full quantum)                                     ║\n * ║         ▼                                                                 ║\n * ║   QUEUE 2 (Lowest Priority)  ─ Quantum: 16 ─ CPU-bound processes         ║\n * ║                                                                           ║\n * ║   Note: Lower queues have LARGER quantums - if you're CPU-bound,         ║\n * ║   might as well let you run longer per turn (fewer context switches).    ║\n * ║                                                                           ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { SchedulingStrategy } from './SchedulingStrategy';\n\nexport class MLFQStrategy extends SchedulingStrategy {\n  /**\n   * Create MLFQ Strategy\n   * \n   * @param {number} numQueues - Number of priority queues (default: 3)\n   * @param {number[]} quantums - Time quantum for each queue level\n   * @param {number} boostInterval - Time between priority boosts (to prevent starvation)\n   */\n  constructor(numQueues = 3, quantums = [4, 8, 16], boostInterval = 50) {\n    super();\n    \n    this.name = 'MLFQ';\n    this.description = `Multi-Level Feedback Queue: The most sophisticated scheduler. \nProcesses start at highest priority. If they use full quantum, they're DEMOTED (CPU-bound penalty). \nIf they yield for I/O, they may be PROMOTED (I/O-bound reward). \nWatch processes move between the 3 priority queues based on their behavior!`;\n    \n    // MLFQ is PREEMPTIVE\n    this.isPreemptive = true;\n    \n    // Number of priority levels\n    this.numQueues = numQueues;\n    \n    /**\n     * TIME QUANTUM PER LEVEL\n     * ──────────────────────\n     * Higher priority queues get SMALLER quantums:\n     * - Quick response for interactive processes\n     * - They don't need long bursts anyway\n     * \n     * Lower priority queues get LARGER quantums:\n     * - CPU-bound processes can make progress\n     * - Fewer context switches for long computations\n     */\n    this.quantums = quantums;\n    \n    // Default time quantum (will be overridden based on queue level)\n    this.timeQuantum = quantums[0];\n    \n    /**\n     * PRIORITY BOOST INTERVAL\n     * ───────────────────────\n     * Periodically boost all processes to top queue.\n     * This prevents STARVATION of CPU-bound processes.\n     * \n     * Without this, a CPU-bound process could be stuck in the\n     * lowest queue forever if interactive processes keep arriving.\n     */\n    this.boostInterval = boostInterval;\n    this.timeSinceLastBoost = 0;\n  }\n  \n  /**\n   * Initialize a new process - assign to highest priority queue\n   * \n   * MLFQ RULE 3: New processes enter at top priority\n   * This gives new processes a chance to show they're interactive.\n   * \n   * @param {Process} process - Newly admitted process\n   */\n  onProcessAdmit(process) {\n    process.queueLevel = 0; // Start at highest priority\n    process.quantumUsed = 0; // Reset quantum tracking\n  }\n  \n  /**\n   * Get time quantum for a process based on its queue level\n   * \n   * @param {Process} process - The process\n   * @returns {number} - Time quantum for this process\n   */\n  getQuantum(process) {\n    const level = process.queueLevel || 0;\n    return this.quantums[Math.min(level, this.quantums.length - 1)];\n  }\n  \n  /**\n   * Select next process using MLFQ rules\n   * \n   * @param {Process[]} readyQueue - All waiting processes\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - Highest priority process to run\n   */\n  selectNext(readyQueue, currentTime) {\n    if (readyQueue.length === 0) {\n      return null;\n    }\n    \n    /**\n     * MLFQ SELECTION ALGORITHM:\n     * ─────────────────────────\n     * 1. Check each queue from highest priority (0) to lowest\n     * 2. Return first process found in non-empty queue\n     * 3. Within same queue, use Round Robin (FIFO)\n     * \n     * RULE 1 & 2 in action:\n     * - Higher priority always runs first (Rule 1)\n     * - Same priority uses Round Robin (Rule 2)\n     */\n    \n    // Group processes by queue level\n    const queues = Array.from({ length: this.numQueues }, () => []);\n    \n    for (const process of readyQueue) {\n      const level = Math.min(process.queueLevel || 0, this.numQueues - 1);\n      queues[level].push(process);\n    }\n    \n    // Find highest priority non-empty queue\n    for (let level = 0; level < this.numQueues; level++) {\n      if (queues[level].length > 0) {\n        // Within queue, sort by arrival time (FIFO for Round Robin)\n        queues[level].sort((a, b) => a.arrivalTime - b.arrivalTime);\n        \n        // Update timeQuantum to match selected process's queue\n        this.timeQuantum = this.quantums[level];\n        \n        return queues[level][0];\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Check if running process should be preempted\n   * \n   * Preempt if:\n   * 1. Quantum expired for current queue level\n   * 2. Higher priority process arrived\n   * \n   * @param {Process} runningProcess - Currently running process\n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} quantumRemaining - Time remaining in current quantum\n   * @returns {boolean} - True if should preempt\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    // Check if quantum expired (Rule 4a trigger)\n    if (quantumRemaining <= 0) {\n      return true;\n    }\n    \n    // Check if higher priority process is waiting (Rule 1)\n    const runningLevel = runningProcess.queueLevel || 0;\n    const higherPriorityWaiting = readyQueue.some(p => \n      (p.queueLevel || 0) < runningLevel\n    );\n    \n    /**\n     * PREEMPTION FOR HIGHER PRIORITY:\n     * ────────────────────────────────\n     * If a process in a higher priority queue is waiting,\n     * preempt the current process to run it.\n     * \n     * This ensures interactive processes get quick response time.\n     */\n    return higherPriorityWaiting;\n  }\n  \n  /**\n   * Perform periodic priority boost (Rule 5)\n   * \n   * @param {Process[]} allProcesses - All processes in system\n   */\n  performBoost(allProcesses) {\n    this.timeSinceLastBoost = 0;\n    \n    for (const process of allProcesses) {\n      process.queueLevel = 0;\n      process.quantumUsed = 0;\n    }\n  }\n  \n  /**\n   * Check if boost is due\n   * \n   * @returns {boolean} - True if boost should happen\n   */\n  isBoostDue() {\n    return this.timeSinceLastBoost >= this.boostInterval;\n  }\n  \n  /**\n   * Update time tracking for boost\n   * \n   * @param {number} elapsed - Time elapsed\n   */\n  updateTime(elapsed) {\n    this.timeSinceLastBoost += elapsed;\n  }\n  \n  /**\n   * Get visual representation of queue structure for UI\n   * \n   * @param {Process[]} readyQueue - All waiting processes\n   * @returns {Object[]} - Queue structure with processes\n   */\n  getQueueStructure(readyQueue) {\n    const structure = [];\n    \n    for (let level = 0; level < this.numQueues; level++) {\n      const processesInQueue = readyQueue.filter(p => \n        (p.queueLevel || 0) === level\n      );\n      \n      structure.push({\n        level,\n        quantum: this.quantums[level],\n        priority: level === 0 ? 'Highest' : level === this.numQueues - 1 ? 'Lowest' : 'Medium',\n        processes: processesInQueue.map(p => p.toSnapshot()),\n        label: `Queue ${level} (Q=${this.quantums[level]})`\n      });\n    }\n    \n    return structure;\n  }\n}\n\nexport default MLFQStrategy;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,kBAAkB,QAAQ,sBAAsB;AAEzD,OAAO,MAAMC,YAAY,SAASD,kBAAkB,CAAC;EACnD;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,WAAWA,CAACC,SAAS,GAAG,CAAC,EAAEC,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAEC,aAAa,GAAG,EAAE,EAAE;IACpE,KAAK,CAAC,CAAC;IAEP,IAAI,CAACC,IAAI,GAAG,MAAM;IAClB,IAAI,CAACC,WAAW,GAAG;AACvB;AACA;AACA,4EAA4E;;IAExE;IACA,IAAI,CAACC,YAAY,GAAG,IAAI;;IAExB;IACA,IAAI,CAACL,SAAS,GAAGA,SAAS;;IAE1B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAGA,QAAQ;;IAExB;IACA,IAAI,CAACK,WAAW,GAAGL,QAAQ,CAAC,CAAC,CAAC;;IAE9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACK,kBAAkB,GAAG,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,cAAcA,CAACC,OAAO,EAAE;IACtBA,OAAO,CAACC,UAAU,GAAG,CAAC,CAAC,CAAC;IACxBD,OAAO,CAACE,WAAW,GAAG,CAAC,CAAC,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAACH,OAAO,EAAE;IA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}