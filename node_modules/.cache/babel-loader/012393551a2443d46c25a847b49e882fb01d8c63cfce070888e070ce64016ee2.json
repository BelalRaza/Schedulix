{"ast":null,"code":"/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║              FIRST-COME, FIRST-SERVED (FCFS) STRATEGY                     ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The simplest scheduling algorithm: processes are executed in the order    ║\n * ║ they arrive. Like a queue at a bank - first in line, first served.       ║\n * ║                                                                           ║\n * ║ CHARACTERISTICS:                                                          ║\n * ║ ────────────────                                                          ║\n * ║ ✓ Simple to implement (just a FIFO queue)                                ║\n * ║ ✓ No starvation (every process eventually runs)                          ║\n * ║ ✓ No preemption overhead                                                 ║\n * ║ ✗ Poor average waiting time                                              ║\n * ║ ✗ CONVOY EFFECT - short processes stuck behind long ones                 ║\n * ║ ✗ Not suitable for interactive systems                                   ║\n * ║                                                                           ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐   ║\n * ║ │                      THE CONVOY EFFECT                              │   ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤   ║\n * ║ │                                                                     │   ║\n * ║ │  Imagine this scenario:                                            │   ║\n * ║ │                                                                     │   ║\n * ║ │  Process A: Burst Time = 100 (CPU-intensive)                       │   ║\n * ║ │  Process B: Burst Time = 2   (Quick I/O operation)                 │   ║\n * ║ │  Process C: Burst Time = 3   (Quick computation)                   │   ║\n * ║ │  Process D: Burst Time = 1   (Very short task)                     │   ║\n * ║ │                                                                     │   ║\n * ║ │  If A arrives first:                                               │   ║\n * ║ │  - B, C, D must wait 100 time units!                               │   ║\n * ║ │  - Average waiting time = (0 + 100 + 102 + 105) / 4 = 76.75        │   ║\n * ║ │                                                                     │   ║\n * ║ │  Like a convoy of slow trucks blocking a highway.                  │   ║\n * ║ │                                                                     │   ║\n * ║ └─────────────────────────────────────────────────────────────────────┘   ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { SchedulingStrategy } from './SchedulingStrategy';\nexport class FCFSStrategy extends SchedulingStrategy {\n  constructor() {\n    super();\n    this.name = 'FCFS';\n    this.description = `First-Come, First-Served: The simplest scheduling algorithm. \nProcesses are executed in order of arrival. Non-preemptive - once a process starts, \nit runs to completion. Watch for the CONVOY EFFECT when a long process arrives first!`;\n\n    // FCFS is NON-PREEMPTIVE\n    // Once a process starts, it runs until completion or I/O block\n    this.isPreemptive = false;\n    this.timeQuantum = null; // No time slicing\n  }\n\n  /**\n   * Select the process that arrived earliest\n   * \n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - First process in queue (by arrival time)\n   */\n  selectNext(readyQueue, currentTime) {\n    if (readyQueue.length === 0) {\n      return null;\n    }\n\n    /**\n     * FCFS Selection Logic:\n     * ─────────────────────\n     * Simply return the process that has been waiting the longest\n     * (i.e., the one that arrived first and hasn't been served yet)\n     * \n     * Since we add processes to readyQueue in arrival order,\n     * we can just return the first element.\n     * \n     * However, to be safe and handle edge cases, we sort by arrival time.\n     */\n\n    // Sort by arrival time (ascending) - earliest arrival first\n    const sorted = [...readyQueue].sort((a, b) => a.arrivalTime - b.arrivalTime);\n    return sorted[0];\n  }\n\n  /**\n   * FCFS never preempts - process runs until completion or voluntary yield\n   * \n   * @returns {boolean} - Always false for FCFS\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    // FCFS is non-preemptive: once a process starts, it keeps running\n    // until it completes or voluntarily blocks for I/O\n    return false;\n  }\n}\nexport default FCFSStrategy;","map":{"version":3,"names":["SchedulingStrategy","FCFSStrategy","constructor","name","description","isPreemptive","timeQuantum","selectNext","readyQueue","currentTime","length","sorted","sort","a","b","arrivalTime","shouldPreempt","runningProcess","quantumRemaining"],"sources":["/Users/belalraza/Desktop/osPROJECT/src/core/strategies/FCFSStrategy.js"],"sourcesContent":["/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║              FIRST-COME, FIRST-SERVED (FCFS) STRATEGY                     ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The simplest scheduling algorithm: processes are executed in the order    ║\n * ║ they arrive. Like a queue at a bank - first in line, first served.       ║\n * ║                                                                           ║\n * ║ CHARACTERISTICS:                                                          ║\n * ║ ────────────────                                                          ║\n * ║ ✓ Simple to implement (just a FIFO queue)                                ║\n * ║ ✓ No starvation (every process eventually runs)                          ║\n * ║ ✓ No preemption overhead                                                 ║\n * ║ ✗ Poor average waiting time                                              ║\n * ║ ✗ CONVOY EFFECT - short processes stuck behind long ones                 ║\n * ║ ✗ Not suitable for interactive systems                                   ║\n * ║                                                                           ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐   ║\n * ║ │                      THE CONVOY EFFECT                              │   ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤   ║\n * ║ │                                                                     │   ║\n * ║ │  Imagine this scenario:                                            │   ║\n * ║ │                                                                     │   ║\n * ║ │  Process A: Burst Time = 100 (CPU-intensive)                       │   ║\n * ║ │  Process B: Burst Time = 2   (Quick I/O operation)                 │   ║\n * ║ │  Process C: Burst Time = 3   (Quick computation)                   │   ║\n * ║ │  Process D: Burst Time = 1   (Very short task)                     │   ║\n * ║ │                                                                     │   ║\n * ║ │  If A arrives first:                                               │   ║\n * ║ │  - B, C, D must wait 100 time units!                               │   ║\n * ║ │  - Average waiting time = (0 + 100 + 102 + 105) / 4 = 76.75        │   ║\n * ║ │                                                                     │   ║\n * ║ │  Like a convoy of slow trucks blocking a highway.                  │   ║\n * ║ │                                                                     │   ║\n * ║ └─────────────────────────────────────────────────────────────────────┘   ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { SchedulingStrategy } from './SchedulingStrategy';\n\nexport class FCFSStrategy extends SchedulingStrategy {\n  constructor() {\n    super();\n    \n    this.name = 'FCFS';\n    this.description = `First-Come, First-Served: The simplest scheduling algorithm. \nProcesses are executed in order of arrival. Non-preemptive - once a process starts, \nit runs to completion. Watch for the CONVOY EFFECT when a long process arrives first!`;\n    \n    // FCFS is NON-PREEMPTIVE\n    // Once a process starts, it runs until completion or I/O block\n    this.isPreemptive = false;\n    this.timeQuantum = null; // No time slicing\n  }\n  \n  /**\n   * Select the process that arrived earliest\n   * \n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - First process in queue (by arrival time)\n   */\n  selectNext(readyQueue, currentTime) {\n    if (readyQueue.length === 0) {\n      return null;\n    }\n    \n    /**\n     * FCFS Selection Logic:\n     * ─────────────────────\n     * Simply return the process that has been waiting the longest\n     * (i.e., the one that arrived first and hasn't been served yet)\n     * \n     * Since we add processes to readyQueue in arrival order,\n     * we can just return the first element.\n     * \n     * However, to be safe and handle edge cases, we sort by arrival time.\n     */\n    \n    // Sort by arrival time (ascending) - earliest arrival first\n    const sorted = [...readyQueue].sort((a, b) => a.arrivalTime - b.arrivalTime);\n    \n    return sorted[0];\n  }\n  \n  /**\n   * FCFS never preempts - process runs until completion or voluntary yield\n   * \n   * @returns {boolean} - Always false for FCFS\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    // FCFS is non-preemptive: once a process starts, it keeps running\n    // until it completes or voluntarily blocks for I/O\n    return false;\n  }\n}\n\nexport default FCFSStrategy;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,kBAAkB,QAAQ,sBAAsB;AAEzD,OAAO,MAAMC,YAAY,SAASD,kBAAkB,CAAC;EACnDE,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;IAEP,IAAI,CAACC,IAAI,GAAG,MAAM;IAClB,IAAI,CAACC,WAAW,GAAG;AACvB;AACA,sFAAsF;;IAElF;IACA;IACA,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB,IAAI,CAACC,WAAW,GAAG,IAAI,CAAC,CAAC;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAACC,UAAU,EAAEC,WAAW,EAAE;IAClC,IAAID,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;MAC3B,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEI;IACA,MAAMC,MAAM,GAAG,CAAC,GAAGH,UAAU,CAAC,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,WAAW,GAAGD,CAAC,CAACC,WAAW,CAAC;IAE5E,OAAOJ,MAAM,CAAC,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;EACEK,aAAaA,CAACC,cAAc,EAAET,UAAU,EAAEU,gBAAgB,EAAE;IAC1D;IACA;IACA,OAAO,KAAK;EACd;AACF;AAEA,eAAejB,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}