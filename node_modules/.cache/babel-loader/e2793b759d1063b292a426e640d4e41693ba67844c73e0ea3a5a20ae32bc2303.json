{"ast":null,"code":"/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║                    SCHEDULING STRATEGY (Abstract Base)                     ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ This is the STRATEGY interface in the Strategy Design Pattern.            ║\n * ║                                                                           ║\n * ║ STRATEGY PATTERN BENEFITS:                                                ║\n * ║ ─────────────────────────                                                 ║\n * ║ 1. ENCAPSULATION: Each algorithm is encapsulated in its own class        ║\n * ║ 2. FLEXIBILITY: Algorithms can be swapped at runtime                      ║\n * ║ 3. EXTENSIBILITY: New algorithms can be added without modifying existing ║\n * ║ 4. TESTABILITY: Each algorithm can be tested independently               ║\n * ║                                                                           ║\n * ║ In real operating systems, the scheduler is often not easily swappable,  ║\n * ║ but Linux does support different scheduling policies (SCHED_FIFO,         ║\n * ║ SCHED_RR, SCHED_OTHER) that can be selected per-process.                 ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\n/**\n * Base class for all scheduling strategies\n * \n * Each concrete strategy must implement:\n * - selectNext(): Choose the next process to run\n * - shouldPreempt(): Determine if running process should be preempted\n */\nexport class SchedulingStrategy {\n  constructor() {\n    // Display name of the algorithm\n    this.name = 'Unknown Strategy';\n\n    // Educational description explaining the algorithm\n    this.description = '';\n\n    // Time quantum for preemptive algorithms (null for non-preemptive)\n    this.timeQuantum = null;\n\n    // Is this algorithm preemptive?\n    this.isPreemptive = false;\n  }\n\n  /**\n   * Select the next process to run from the ready queue\n   * \n   * This is the core of the scheduling algorithm - different strategies\n   * implement this differently based on their scheduling policy.\n   * \n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - The next process to run, or null if queue is empty\n   */\n  selectNext(readyQueue, currentTime) {\n    throw new Error('selectNext() must be implemented by concrete strategy');\n  }\n\n  /**\n   * Determine if the currently running process should be preempted\n   * \n   * @param {Process} runningProcess - Currently running process\n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} quantumRemaining - Time remaining in current quantum\n   * @returns {boolean} - True if process should be preempted\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    // Default: no preemption for non-preemptive algorithms\n    return false;\n  }\n\n  /**\n   * Called when a new process is admitted to the system\n   * Useful for MLFQ to initialize queue assignment\n   * \n   * @param {Process} process - Newly admitted process\n   */\n  onProcessAdmit(process) {\n    // Default: do nothing\n  }\n\n  /**\n   * Get the current time quantum (for Round Robin and MLFQ)\n   * \n   * @param {Process} process - The process being scheduled\n   * @returns {number} - Time quantum for this process\n   */\n  getQuantum(process) {\n    return this.timeQuantum || Infinity;\n  }\n\n  /**\n   * Get educational information about this algorithm\n   */\n  getInfo() {\n    return {\n      name: this.name,\n      description: this.description,\n      isPreemptive: this.isPreemptive,\n      timeQuantum: this.timeQuantum\n    };\n  }\n}\nexport default SchedulingStrategy;","map":{"version":3,"names":["SchedulingStrategy","constructor","name","description","timeQuantum","isPreemptive","selectNext","readyQueue","currentTime","Error","shouldPreempt","runningProcess","quantumRemaining","onProcessAdmit","process","getQuantum","Infinity","getInfo"],"sources":["/Users/belalraza/Desktop/osPROJECT/src/core/strategies/SchedulingStrategy.js"],"sourcesContent":["/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║                    SCHEDULING STRATEGY (Abstract Base)                     ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ This is the STRATEGY interface in the Strategy Design Pattern.            ║\n * ║                                                                           ║\n * ║ STRATEGY PATTERN BENEFITS:                                                ║\n * ║ ─────────────────────────                                                 ║\n * ║ 1. ENCAPSULATION: Each algorithm is encapsulated in its own class        ║\n * ║ 2. FLEXIBILITY: Algorithms can be swapped at runtime                      ║\n * ║ 3. EXTENSIBILITY: New algorithms can be added without modifying existing ║\n * ║ 4. TESTABILITY: Each algorithm can be tested independently               ║\n * ║                                                                           ║\n * ║ In real operating systems, the scheduler is often not easily swappable,  ║\n * ║ but Linux does support different scheduling policies (SCHED_FIFO,         ║\n * ║ SCHED_RR, SCHED_OTHER) that can be selected per-process.                 ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\n/**\n * Base class for all scheduling strategies\n * \n * Each concrete strategy must implement:\n * - selectNext(): Choose the next process to run\n * - shouldPreempt(): Determine if running process should be preempted\n */\nexport class SchedulingStrategy {\n  constructor() {\n    // Display name of the algorithm\n    this.name = 'Unknown Strategy';\n    \n    // Educational description explaining the algorithm\n    this.description = '';\n    \n    // Time quantum for preemptive algorithms (null for non-preemptive)\n    this.timeQuantum = null;\n    \n    // Is this algorithm preemptive?\n    this.isPreemptive = false;\n  }\n  \n  /**\n   * Select the next process to run from the ready queue\n   * \n   * This is the core of the scheduling algorithm - different strategies\n   * implement this differently based on their scheduling policy.\n   * \n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - The next process to run, or null if queue is empty\n   */\n  selectNext(readyQueue, currentTime) {\n    throw new Error('selectNext() must be implemented by concrete strategy');\n  }\n  \n  /**\n   * Determine if the currently running process should be preempted\n   * \n   * @param {Process} runningProcess - Currently running process\n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} quantumRemaining - Time remaining in current quantum\n   * @returns {boolean} - True if process should be preempted\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    // Default: no preemption for non-preemptive algorithms\n    return false;\n  }\n  \n  /**\n   * Called when a new process is admitted to the system\n   * Useful for MLFQ to initialize queue assignment\n   * \n   * @param {Process} process - Newly admitted process\n   */\n  onProcessAdmit(process) {\n    // Default: do nothing\n  }\n  \n  /**\n   * Get the current time quantum (for Round Robin and MLFQ)\n   * \n   * @param {Process} process - The process being scheduled\n   * @returns {number} - Time quantum for this process\n   */\n  getQuantum(process) {\n    return this.timeQuantum || Infinity;\n  }\n  \n  /**\n   * Get educational information about this algorithm\n   */\n  getInfo() {\n    return {\n      name: this.name,\n      description: this.description,\n      isPreemptive: this.isPreemptive,\n      timeQuantum: this.timeQuantum\n    };\n  }\n}\n\nexport default SchedulingStrategy;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,kBAAkB,CAAC;EAC9BC,WAAWA,CAAA,EAAG;IACZ;IACA,IAAI,CAACC,IAAI,GAAG,kBAAkB;;IAE9B;IACA,IAAI,CAACC,WAAW,GAAG,EAAE;;IAErB;IACA,IAAI,CAACC,WAAW,GAAG,IAAI;;IAEvB;IACA,IAAI,CAACC,YAAY,GAAG,KAAK;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAACC,UAAU,EAAEC,WAAW,EAAE;IAClC,MAAM,IAAIC,KAAK,CAAC,uDAAuD,CAAC;EAC1E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAACC,cAAc,EAAEJ,UAAU,EAAEK,gBAAgB,EAAE;IAC1D;IACA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,cAAcA,CAACC,OAAO,EAAE;IACtB;EAAA;;EAGF;AACF;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAACD,OAAO,EAAE;IAClB,OAAO,IAAI,CAACV,WAAW,IAAIY,QAAQ;EACrC;;EAEA;AACF;AACA;EACEC,OAAOA,CAAA,EAAG;IACR,OAAO;MACLf,IAAI,EAAE,IAAI,CAACA,IAAI;MACfC,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BE,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BD,WAAW,EAAE,IAAI,CAACA;IACpB,CAAC;EACH;AACF;AAEA,eAAeJ,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}