{"ast":null,"code":"/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║                           PROCESS CLASS                                    ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The Process is the fundamental unit of work in an operating system.       ║\n * ║                                                                           ║\n * ║ In real OS terms, a process is a program in execution. It contains:       ║\n * ║   - Program code (text section)                                           ║\n * ║   - Current activity (program counter, registers)                         ║\n * ║   - Stack (temporary data like function parameters, return addresses)     ║\n * ║   - Data section (global variables)                                       ║\n * ║   - Heap (dynamically allocated memory)                                   ║\n * ║                                                                           ║\n * ║ For our visualizer, we abstract this to focus on scheduling attributes.   ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Process States Enumeration\n * \n * ┌─────────────────────────────────────────────────────────────────┐\n * │                    PROCESS STATE DIAGRAM                        │\n * │                                                                 │\n * │   ┌─────────┐      admitted       ┌─────────┐                  │\n * │   │   NEW   │ ─────────────────▶  │  READY  │ ◀──────────┐     │\n * │   └─────────┘                     └────┬────┘            │     │\n * │                                        │                 │     │\n * │                              scheduler │                 │     │\n * │                               dispatch │          I/O or │     │\n * │                                        ▼          event  │     │\n * │                                   ┌─────────┐   complete │     │\n * │                                   │ RUNNING │            │     │\n * │                                   └────┬────┘            │     │\n * │                                        │                 │     │\n * │                    ┌───────────────────┼───────────────┐ │     │\n * │                    │                   │               │ │     │\n * │                    ▼                   ▼               ▼ │     │\n * │             ┌───────────┐      ┌─────────────┐   ┌─────────┐   │\n * │             │TERMINATED │      │ I/O or event│   │interrupt│   │\n * │             └───────────┘      │    wait     │   │(preempt)│   │\n * │                                └──────┬──────┘   └────┬────┘   │\n * │                                       │               │        │\n * │                                       ▼               │        │\n * │                                ┌───────────┐          │        │\n * │                                │  WAITING  │──────────┘        │\n * │                                └───────────┘                   │\n * └─────────────────────────────────────────────────────────────────┘\n * \n * KEY CONCEPT: Preemption\n * ─────────────────────────\n * Preemption is the act of temporarily interrupting an executing process,\n * without its cooperation, with the intent of resuming it later.\n * \n * - Non-preemptive scheduling: Once a process starts running, it continues\n *   until it voluntarily releases the CPU (by terminating or blocking for I/O).\n *   Example: FCFS, Non-preemptive SJF\n * \n * - Preemptive scheduling: The OS can forcibly remove a running process from\n *   the CPU, typically when a time quantum expires or a higher-priority\n *   process arrives.\n *   Example: Round Robin, MLFQ, Preemptive SJF\n */\nexport const ProcessState = {\n  NEW: 'NEW',\n  // Process has been created but not yet admitted to ready queue\n  READY: 'READY',\n  // Process is waiting in queue to be assigned to CPU\n  RUNNING: 'RUNNING',\n  // Process is currently being executed by CPU\n  WAITING: 'WAITING',\n  // Process is waiting for I/O or an event (blocked state)\n  TERMINATED: 'TERMINATED' // Process has finished execution\n};\n\n/**\n * Process Class\n * \n * Represents a process in our CPU scheduling simulation.\n * Each process has attributes that determine how it's scheduled.\n */\nexport class Process {\n  /**\n   * Creates a new Process instance\n   * \n   * @param {Object} config - Process configuration\n   * @param {string} config.name - Human-readable process name (e.g., \"P1\", \"Browser\")\n   * @param {number} config.arrivalTime - Time at which process enters the system\n   * @param {number} config.burstTime - Total CPU time required to complete\n   * @param {number} config.priority - Priority level (lower number = higher priority in most systems)\n   * @param {number} config.ioFrequency - How often process requests I/O (0 = never)\n   */\n  constructor({\n    name,\n    arrivalTime = 0,\n    burstTime,\n    priority = 5,\n    ioFrequency = 0\n  }) {\n    // Unique identifier for the process (simulates Process ID in real OS)\n    this.id = uuidv4();\n\n    // Human-readable name for display purposes\n    this.name = name;\n\n    /**\n     * ARRIVAL TIME\n     * ─────────────\n     * The time at which the process enters the ready queue.\n     * In real systems, this is when a program is launched or a new task is created.\n     * \n     * This is crucial for:\n     * - FCFS: Determines order of execution\n     * - SJF: Used with burst time to calculate optimal scheduling\n     * - All algorithms: Calculating waiting time and turnaround time\n     */\n    this.arrivalTime = arrivalTime;\n\n    /**\n     * BURST TIME (CPU Burst)\n     * ──────────────────────\n     * The total amount of CPU time the process needs to complete.\n     * \n     * In reality, this is unknown - the OS uses various prediction techniques:\n     * - Exponential averaging of previous CPU bursts\n     * - Static analysis of program code\n     * - User hints/declarations\n     * \n     * For our visualizer, we specify it upfront for educational clarity.\n     */\n    this.burstTime = burstTime;\n\n    // Remaining burst time (decreases as process executes)\n    this.remainingTime = burstTime;\n\n    /**\n     * PRIORITY\n     * ────────\n     * A value indicating the process's importance.\n     * \n     * Priority can be:\n     * - Statically assigned (based on process type, user, etc.)\n     * - Dynamically calculated (based on waiting time, CPU usage, etc.)\n     * \n     * CAUTION: Priority scheduling can lead to STARVATION\n     * ──────────────────────────────────────────────────────\n     * Starvation occurs when a low-priority process waits indefinitely\n     * because higher-priority processes keep arriving.\n     * \n     * Solution: AGING - gradually increasing priority of waiting processes\n     */\n    this.priority = priority;\n\n    // Current queue level for MLFQ (0 = highest priority queue)\n    this.queueLevel = 0;\n\n    // Current state of the process\n    this.state = ProcessState.NEW;\n\n    // How often process requests I/O (0 = CPU-bound, higher = I/O-bound)\n    this.ioFrequency = ioFrequency;\n\n    // Tracking I/O operations\n    this.ioRemaining = 0; // Time remaining in I/O operation\n\n    /**\n     * METRICS FOR ANALYSIS\n     * ────────────────────\n     * These help us calculate important scheduling metrics:\n     */\n\n    // Time when process first started executing\n    this.startTime = null;\n\n    // Time when process completed execution\n    this.completionTime = null;\n\n    // Total time spent waiting in ready queue\n    // WAITING TIME = Turnaround Time - Burst Time\n    this.waitingTime = 0;\n\n    // Time spent in current wait (reset each time process enters ready queue)\n    this.currentWaitStart = null;\n\n    /**\n     * TURNAROUND TIME\n     * ───────────────\n     * Total time from arrival to completion.\n     * Turnaround Time = Completion Time - Arrival Time\n     * \n     * This includes:\n     * - Waiting time in ready queue\n     * - Execution time\n     * - Time spent blocked for I/O\n     */\n    this.turnaroundTime = null;\n\n    /**\n     * RESPONSE TIME\n     * ─────────────\n     * Time from arrival to first execution.\n     * Response Time = First Execution Time - Arrival Time\n     * \n     * Important for interactive systems where users expect quick feedback.\n     */\n    this.responseTime = null;\n\n    // Visual properties\n    this.color = this.generateColor();\n\n    // Time quantum used in current queue (for MLFQ tracking)\n    this.quantumUsed = 0;\n  }\n\n  /**\n   * Generate a unique color for this process\n   * Uses HSL to ensure good saturation and visibility\n   */\n  generateColor() {\n    // Generate a hue based on the process name for consistency\n    const hash = this.name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    const hue = hash * 137 % 360; // Golden ratio distribution\n    return `hsl(${hue}, 70%, 55%)`;\n  }\n\n  /**\n   * Transition process to a new state\n   * Validates state transitions according to process lifecycle\n   * \n   * @param {string} newState - The target state\n   * @param {number} currentTime - Current simulation time\n   */\n  setState(newState, currentTime) {\n    const oldState = this.state;\n\n    // Validate state transition\n    const validTransitions = {\n      [ProcessState.NEW]: [ProcessState.READY],\n      [ProcessState.READY]: [ProcessState.RUNNING, ProcessState.TERMINATED],\n      [ProcessState.RUNNING]: [ProcessState.READY, ProcessState.WAITING, ProcessState.TERMINATED],\n      [ProcessState.WAITING]: [ProcessState.READY],\n      [ProcessState.TERMINATED]: [] // Terminal state - no transitions out\n    };\n    if (!validTransitions[oldState].includes(newState)) {\n      console.warn(`Invalid state transition: ${oldState} -> ${newState}`);\n      return false;\n    }\n\n    // Handle state-specific logic\n    switch (newState) {\n      case ProcessState.READY:\n        // Process entering ready queue - start tracking wait time\n        this.currentWaitStart = currentTime;\n        this.quantumUsed = 0; // Reset quantum tracking\n        break;\n      case ProcessState.RUNNING:\n        // Process starting/resuming execution\n        if (this.currentWaitStart !== null) {\n          this.waitingTime += currentTime - this.currentWaitStart;\n          this.currentWaitStart = null;\n        }\n        if (this.startTime === null) {\n          // First time running - record start time and response time\n          this.startTime = currentTime;\n          this.responseTime = currentTime - this.arrivalTime;\n        }\n        break;\n      case ProcessState.WAITING:\n        // Process blocked for I/O\n        // Note: This doesn't count as waiting time (process chose to wait)\n        break;\n      case ProcessState.TERMINATED:\n        // Process completed - calculate final metrics\n        this.completionTime = currentTime;\n        this.turnaroundTime = this.completionTime - this.arrivalTime;\n        this.remainingTime = 0;\n        break;\n      default:\n        break;\n    }\n    this.state = newState;\n    return true;\n  }\n\n  /**\n   * Execute the process for a given time slice\n   * \n   * @param {number} timeSlice - Duration to execute\n   * @returns {Object} - Execution result with actual time used and completion status\n   */\n  execute(timeSlice) {\n    const actualTime = Math.min(timeSlice, this.remainingTime);\n    this.remainingTime -= actualTime;\n    this.quantumUsed += actualTime;\n    return {\n      timeUsed: actualTime,\n      completed: this.remainingTime === 0,\n      // Check if process should do I/O (random based on ioFrequency)\n      requestsIO: this.ioFrequency > 0 && Math.random() < this.ioFrequency && this.remainingTime > 0\n    };\n  }\n\n  /**\n   * Start an I/O operation\n   * \n   * @param {number} ioDuration - How long the I/O takes\n   */\n  startIO(ioDuration) {\n    this.ioRemaining = ioDuration;\n  }\n\n  /**\n   * Process I/O completion\n   * \n   * @param {number} elapsed - Time elapsed\n   * @returns {boolean} - True if I/O is complete\n   */\n  processIO(elapsed) {\n    this.ioRemaining = Math.max(0, this.ioRemaining - elapsed);\n    return this.ioRemaining === 0;\n  }\n\n  /**\n   * Demote process to lower priority queue (for MLFQ)\n   * \n   * MLFQ RULE: If a process uses its entire time quantum,\n   * it is demoted to a lower priority queue (penalized for CPU-bound behavior)\n   */\n  demote(maxQueueLevel) {\n    if (this.queueLevel < maxQueueLevel) {\n      this.queueLevel++;\n      this.quantumUsed = 0;\n    }\n  }\n\n  /**\n   * Promote process to higher priority queue (for MLFQ)\n   * \n   * MLFQ RULE: If a process voluntarily yields the CPU (e.g., for I/O),\n   * it may be promoted to a higher priority queue (rewarded for I/O-bound behavior)\n   */\n  promote() {\n    if (this.queueLevel > 0) {\n      this.queueLevel--;\n      this.quantumUsed = 0;\n    }\n  }\n\n  /**\n   * Reset process for re-running simulations\n   */\n  reset() {\n    this.remainingTime = this.burstTime;\n    this.state = ProcessState.NEW;\n    this.queueLevel = 0;\n    this.startTime = null;\n    this.completionTime = null;\n    this.waitingTime = 0;\n    this.currentWaitStart = null;\n    this.turnaroundTime = null;\n    this.responseTime = null;\n    this.ioRemaining = 0;\n    this.quantumUsed = 0;\n  }\n\n  /**\n   * Create a snapshot of process state for visualization\n   */\n  toSnapshot() {\n    return {\n      id: this.id,\n      name: this.name,\n      state: this.state,\n      arrivalTime: this.arrivalTime,\n      burstTime: this.burstTime,\n      remainingTime: this.remainingTime,\n      priority: this.priority,\n      queueLevel: this.queueLevel,\n      waitingTime: this.waitingTime,\n      color: this.color,\n      progress: (this.burstTime - this.remainingTime) / this.burstTime * 100\n    };\n  }\n}\nexport default Process;","map":{"version":3,"names":["v4","uuidv4","ProcessState","NEW","READY","RUNNING","WAITING","TERMINATED","Process","constructor","name","arrivalTime","burstTime","priority","ioFrequency","id","remainingTime","queueLevel","state","ioRemaining","startTime","completionTime","waitingTime","currentWaitStart","turnaroundTime","responseTime","color","generateColor","quantumUsed","hash","split","reduce","acc","char","charCodeAt","hue","setState","newState","currentTime","oldState","validTransitions","includes","console","warn","execute","timeSlice","actualTime","Math","min","timeUsed","completed","requestsIO","random","startIO","ioDuration","processIO","elapsed","max","demote","maxQueueLevel","promote","reset","toSnapshot","progress"],"sources":["/Users/belalraza/Desktop/osPROJECT/src/core/Process.js"],"sourcesContent":["/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║                           PROCESS CLASS                                    ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The Process is the fundamental unit of work in an operating system.       ║\n * ║                                                                           ║\n * ║ In real OS terms, a process is a program in execution. It contains:       ║\n * ║   - Program code (text section)                                           ║\n * ║   - Current activity (program counter, registers)                         ║\n * ║   - Stack (temporary data like function parameters, return addresses)     ║\n * ║   - Data section (global variables)                                       ║\n * ║   - Heap (dynamically allocated memory)                                   ║\n * ║                                                                           ║\n * ║ For our visualizer, we abstract this to focus on scheduling attributes.   ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Process States Enumeration\n * \n * ┌─────────────────────────────────────────────────────────────────┐\n * │                    PROCESS STATE DIAGRAM                        │\n * │                                                                 │\n * │   ┌─────────┐      admitted       ┌─────────┐                  │\n * │   │   NEW   │ ─────────────────▶  │  READY  │ ◀──────────┐     │\n * │   └─────────┘                     └────┬────┘            │     │\n * │                                        │                 │     │\n * │                              scheduler │                 │     │\n * │                               dispatch │          I/O or │     │\n * │                                        ▼          event  │     │\n * │                                   ┌─────────┐   complete │     │\n * │                                   │ RUNNING │            │     │\n * │                                   └────┬────┘            │     │\n * │                                        │                 │     │\n * │                    ┌───────────────────┼───────────────┐ │     │\n * │                    │                   │               │ │     │\n * │                    ▼                   ▼               ▼ │     │\n * │             ┌───────────┐      ┌─────────────┐   ┌─────────┐   │\n * │             │TERMINATED │      │ I/O or event│   │interrupt│   │\n * │             └───────────┘      │    wait     │   │(preempt)│   │\n * │                                └──────┬──────┘   └────┬────┘   │\n * │                                       │               │        │\n * │                                       ▼               │        │\n * │                                ┌───────────┐          │        │\n * │                                │  WAITING  │──────────┘        │\n * │                                └───────────┘                   │\n * └─────────────────────────────────────────────────────────────────┘\n * \n * KEY CONCEPT: Preemption\n * ─────────────────────────\n * Preemption is the act of temporarily interrupting an executing process,\n * without its cooperation, with the intent of resuming it later.\n * \n * - Non-preemptive scheduling: Once a process starts running, it continues\n *   until it voluntarily releases the CPU (by terminating or blocking for I/O).\n *   Example: FCFS, Non-preemptive SJF\n * \n * - Preemptive scheduling: The OS can forcibly remove a running process from\n *   the CPU, typically when a time quantum expires or a higher-priority\n *   process arrives.\n *   Example: Round Robin, MLFQ, Preemptive SJF\n */\nexport const ProcessState = {\n  NEW: 'NEW',           // Process has been created but not yet admitted to ready queue\n  READY: 'READY',       // Process is waiting in queue to be assigned to CPU\n  RUNNING: 'RUNNING',   // Process is currently being executed by CPU\n  WAITING: 'WAITING',   // Process is waiting for I/O or an event (blocked state)\n  TERMINATED: 'TERMINATED' // Process has finished execution\n};\n\n/**\n * Process Class\n * \n * Represents a process in our CPU scheduling simulation.\n * Each process has attributes that determine how it's scheduled.\n */\nexport class Process {\n  /**\n   * Creates a new Process instance\n   * \n   * @param {Object} config - Process configuration\n   * @param {string} config.name - Human-readable process name (e.g., \"P1\", \"Browser\")\n   * @param {number} config.arrivalTime - Time at which process enters the system\n   * @param {number} config.burstTime - Total CPU time required to complete\n   * @param {number} config.priority - Priority level (lower number = higher priority in most systems)\n   * @param {number} config.ioFrequency - How often process requests I/O (0 = never)\n   */\n  constructor({ name, arrivalTime = 0, burstTime, priority = 5, ioFrequency = 0 }) {\n    // Unique identifier for the process (simulates Process ID in real OS)\n    this.id = uuidv4();\n    \n    // Human-readable name for display purposes\n    this.name = name;\n    \n    /**\n     * ARRIVAL TIME\n     * ─────────────\n     * The time at which the process enters the ready queue.\n     * In real systems, this is when a program is launched or a new task is created.\n     * \n     * This is crucial for:\n     * - FCFS: Determines order of execution\n     * - SJF: Used with burst time to calculate optimal scheduling\n     * - All algorithms: Calculating waiting time and turnaround time\n     */\n    this.arrivalTime = arrivalTime;\n    \n    /**\n     * BURST TIME (CPU Burst)\n     * ──────────────────────\n     * The total amount of CPU time the process needs to complete.\n     * \n     * In reality, this is unknown - the OS uses various prediction techniques:\n     * - Exponential averaging of previous CPU bursts\n     * - Static analysis of program code\n     * - User hints/declarations\n     * \n     * For our visualizer, we specify it upfront for educational clarity.\n     */\n    this.burstTime = burstTime;\n    \n    // Remaining burst time (decreases as process executes)\n    this.remainingTime = burstTime;\n    \n    /**\n     * PRIORITY\n     * ────────\n     * A value indicating the process's importance.\n     * \n     * Priority can be:\n     * - Statically assigned (based on process type, user, etc.)\n     * - Dynamically calculated (based on waiting time, CPU usage, etc.)\n     * \n     * CAUTION: Priority scheduling can lead to STARVATION\n     * ──────────────────────────────────────────────────────\n     * Starvation occurs when a low-priority process waits indefinitely\n     * because higher-priority processes keep arriving.\n     * \n     * Solution: AGING - gradually increasing priority of waiting processes\n     */\n    this.priority = priority;\n    \n    // Current queue level for MLFQ (0 = highest priority queue)\n    this.queueLevel = 0;\n    \n    // Current state of the process\n    this.state = ProcessState.NEW;\n    \n    // How often process requests I/O (0 = CPU-bound, higher = I/O-bound)\n    this.ioFrequency = ioFrequency;\n    \n    // Tracking I/O operations\n    this.ioRemaining = 0; // Time remaining in I/O operation\n    \n    /**\n     * METRICS FOR ANALYSIS\n     * ────────────────────\n     * These help us calculate important scheduling metrics:\n     */\n    \n    // Time when process first started executing\n    this.startTime = null;\n    \n    // Time when process completed execution\n    this.completionTime = null;\n    \n    // Total time spent waiting in ready queue\n    // WAITING TIME = Turnaround Time - Burst Time\n    this.waitingTime = 0;\n    \n    // Time spent in current wait (reset each time process enters ready queue)\n    this.currentWaitStart = null;\n    \n    /**\n     * TURNAROUND TIME\n     * ───────────────\n     * Total time from arrival to completion.\n     * Turnaround Time = Completion Time - Arrival Time\n     * \n     * This includes:\n     * - Waiting time in ready queue\n     * - Execution time\n     * - Time spent blocked for I/O\n     */\n    this.turnaroundTime = null;\n    \n    /**\n     * RESPONSE TIME\n     * ─────────────\n     * Time from arrival to first execution.\n     * Response Time = First Execution Time - Arrival Time\n     * \n     * Important for interactive systems where users expect quick feedback.\n     */\n    this.responseTime = null;\n    \n    // Visual properties\n    this.color = this.generateColor();\n    \n    // Time quantum used in current queue (for MLFQ tracking)\n    this.quantumUsed = 0;\n  }\n  \n  /**\n   * Generate a unique color for this process\n   * Uses HSL to ensure good saturation and visibility\n   */\n  generateColor() {\n    // Generate a hue based on the process name for consistency\n    const hash = this.name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    const hue = (hash * 137) % 360; // Golden ratio distribution\n    return `hsl(${hue}, 70%, 55%)`;\n  }\n  \n  /**\n   * Transition process to a new state\n   * Validates state transitions according to process lifecycle\n   * \n   * @param {string} newState - The target state\n   * @param {number} currentTime - Current simulation time\n   */\n  setState(newState, currentTime) {\n    const oldState = this.state;\n    \n    // Validate state transition\n    const validTransitions = {\n      [ProcessState.NEW]: [ProcessState.READY],\n      [ProcessState.READY]: [ProcessState.RUNNING, ProcessState.TERMINATED],\n      [ProcessState.RUNNING]: [ProcessState.READY, ProcessState.WAITING, ProcessState.TERMINATED],\n      [ProcessState.WAITING]: [ProcessState.READY],\n      [ProcessState.TERMINATED]: [] // Terminal state - no transitions out\n    };\n    \n    if (!validTransitions[oldState].includes(newState)) {\n      console.warn(`Invalid state transition: ${oldState} -> ${newState}`);\n      return false;\n    }\n    \n    // Handle state-specific logic\n    switch (newState) {\n      case ProcessState.READY:\n        // Process entering ready queue - start tracking wait time\n        this.currentWaitStart = currentTime;\n        this.quantumUsed = 0; // Reset quantum tracking\n        break;\n        \n      case ProcessState.RUNNING:\n        // Process starting/resuming execution\n        if (this.currentWaitStart !== null) {\n          this.waitingTime += currentTime - this.currentWaitStart;\n          this.currentWaitStart = null;\n        }\n        if (this.startTime === null) {\n          // First time running - record start time and response time\n          this.startTime = currentTime;\n          this.responseTime = currentTime - this.arrivalTime;\n        }\n        break;\n        \n      case ProcessState.WAITING:\n        // Process blocked for I/O\n        // Note: This doesn't count as waiting time (process chose to wait)\n        break;\n        \n      case ProcessState.TERMINATED:\n        // Process completed - calculate final metrics\n        this.completionTime = currentTime;\n        this.turnaroundTime = this.completionTime - this.arrivalTime;\n        this.remainingTime = 0;\n        break;\n        \n      default:\n        break;\n    }\n    \n    this.state = newState;\n    return true;\n  }\n  \n  /**\n   * Execute the process for a given time slice\n   * \n   * @param {number} timeSlice - Duration to execute\n   * @returns {Object} - Execution result with actual time used and completion status\n   */\n  execute(timeSlice) {\n    const actualTime = Math.min(timeSlice, this.remainingTime);\n    this.remainingTime -= actualTime;\n    this.quantumUsed += actualTime;\n    \n    return {\n      timeUsed: actualTime,\n      completed: this.remainingTime === 0,\n      // Check if process should do I/O (random based on ioFrequency)\n      requestsIO: this.ioFrequency > 0 && Math.random() < this.ioFrequency && this.remainingTime > 0\n    };\n  }\n  \n  /**\n   * Start an I/O operation\n   * \n   * @param {number} ioDuration - How long the I/O takes\n   */\n  startIO(ioDuration) {\n    this.ioRemaining = ioDuration;\n  }\n  \n  /**\n   * Process I/O completion\n   * \n   * @param {number} elapsed - Time elapsed\n   * @returns {boolean} - True if I/O is complete\n   */\n  processIO(elapsed) {\n    this.ioRemaining = Math.max(0, this.ioRemaining - elapsed);\n    return this.ioRemaining === 0;\n  }\n  \n  /**\n   * Demote process to lower priority queue (for MLFQ)\n   * \n   * MLFQ RULE: If a process uses its entire time quantum,\n   * it is demoted to a lower priority queue (penalized for CPU-bound behavior)\n   */\n  demote(maxQueueLevel) {\n    if (this.queueLevel < maxQueueLevel) {\n      this.queueLevel++;\n      this.quantumUsed = 0;\n    }\n  }\n  \n  /**\n   * Promote process to higher priority queue (for MLFQ)\n   * \n   * MLFQ RULE: If a process voluntarily yields the CPU (e.g., for I/O),\n   * it may be promoted to a higher priority queue (rewarded for I/O-bound behavior)\n   */\n  promote() {\n    if (this.queueLevel > 0) {\n      this.queueLevel--;\n      this.quantumUsed = 0;\n    }\n  }\n  \n  /**\n   * Reset process for re-running simulations\n   */\n  reset() {\n    this.remainingTime = this.burstTime;\n    this.state = ProcessState.NEW;\n    this.queueLevel = 0;\n    this.startTime = null;\n    this.completionTime = null;\n    this.waitingTime = 0;\n    this.currentWaitStart = null;\n    this.turnaroundTime = null;\n    this.responseTime = null;\n    this.ioRemaining = 0;\n    this.quantumUsed = 0;\n  }\n  \n  /**\n   * Create a snapshot of process state for visualization\n   */\n  toSnapshot() {\n    return {\n      id: this.id,\n      name: this.name,\n      state: this.state,\n      arrivalTime: this.arrivalTime,\n      burstTime: this.burstTime,\n      remainingTime: this.remainingTime,\n      priority: this.priority,\n      queueLevel: this.queueLevel,\n      waitingTime: this.waitingTime,\n      color: this.color,\n      progress: ((this.burstTime - this.remainingTime) / this.burstTime) * 100\n    };\n  }\n}\n\nexport default Process;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,EAAE,IAAIC,MAAM,QAAQ,MAAM;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,GAAG;EAC1BC,GAAG,EAAE,KAAK;EAAY;EACtBC,KAAK,EAAE,OAAO;EAAQ;EACtBC,OAAO,EAAE,SAAS;EAAI;EACtBC,OAAO,EAAE,SAAS;EAAI;EACtBC,UAAU,EAAE,YAAY,CAAC;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,CAAC;EACnB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAAC;IAAEC,IAAI;IAAEC,WAAW,GAAG,CAAC;IAAEC,SAAS;IAAEC,QAAQ,GAAG,CAAC;IAAEC,WAAW,GAAG;EAAE,CAAC,EAAE;IAC/E;IACA,IAAI,CAACC,EAAE,GAAGd,MAAM,CAAC,CAAC;;IAElB;IACA,IAAI,CAACS,IAAI,GAAGA,IAAI;;IAEhB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,WAAW,GAAGA,WAAW;;IAE9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,SAAS,GAAGA,SAAS;;IAE1B;IACA,IAAI,CAACI,aAAa,GAAGJ,SAAS;;IAE9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAGA,QAAQ;;IAExB;IACA,IAAI,CAACI,UAAU,GAAG,CAAC;;I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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}