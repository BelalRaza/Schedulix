{"ast":null,"code":"/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║                    ROUND ROBIN (RR) STRATEGY                              ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The workhorse of time-sharing systems. Each process gets a fixed TIME     ║\n * ║ QUANTUM (time slice) to execute before being preempted.                   ║\n * ║                                                                           ║\n * ║ This is what creates the ILLUSION OF PARALLELISM!                        ║\n * ║                                                                           ║\n * ║ CHARACTERISTICS:                                                          ║\n * ║ ────────────────                                                          ║\n * ║ ✓ FAIR - every process gets equal CPU time                               ║\n * ║ ✓ No starvation (bounded waiting time)                                   ║\n * ║ ✓ Good response time for interactive processes                           ║\n * ║ ✓ Simple to implement                                                    ║\n * ║ ✗ Performance depends heavily on quantum size                            ║\n * ║ ✗ Context switching overhead with small quantum                          ║\n * ║ ✗ Higher average waiting time than SJF                                   ║\n * ║                                                                           ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐   ║\n * ║ │                    TIME QUANTUM TRADE-OFF                           │   ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤   ║\n * ║ │                                                                     │   ║\n * ║ │  QUANTUM TOO LARGE:                                                │   ║\n * ║ │  ─────────────────                                                  │   ║\n * ║ │  - Degrades to FCFS behavior                                       │   ║\n * ║ │  - Poor response time                                              │   ║\n * ║ │  - Less \"parallelism illusion\"                                     │   ║\n * ║ │                                                                     │   ║\n * ║ │  QUANTUM TOO SMALL:                                                │   ║\n * ║ │  ─────────────────                                                  │   ║\n * ║ │  - Excessive context switching                                     │   ║\n * ║ │  - High overhead (CPU spends time switching, not computing)        │   ║\n * ║ │  - Throughput suffers                                              │   ║\n * ║ │                                                                     │   ║\n * ║ │  SWEET SPOT:                                                       │   ║\n * ║ │  ───────────                                                        │   ║\n * ║ │  Quantum should be large enough that most processes complete       │   ║\n * ║ │  within one quantum, but small enough for good responsiveness.     │   ║\n * ║ │                                                                     │   ║\n * ║ │  Rule of thumb: 80% of CPU bursts should be < quantum              │   ║\n * ║ │  Typical values: 10-100 milliseconds                               │   ║\n * ║ │                                                                     │   ║\n * ║ └─────────────────────────────────────────────────────────────────────┘   ║\n * ║                                                                           ║\n * ║ VISUALIZATION:                                                            ║\n * ║ ─────────────                                                             ║\n * ║                                                                           ║\n * ║   Time: 0    4    8    12   16   20   24   28                            ║\n * ║         |    |    |    |    |    |    |    |                              ║\n * ║         ┌────┐    ┌────┐    ┌────┐    ┌──┐                               ║\n * ║   P1:   │████│    │████│    │████│    │██│ (Burst: 14)                   ║\n * ║         └────┘    └────┘    └────┘    └──┘                               ║\n * ║              ┌────┐    ┌────┐    ┌──┐                                     ║\n * ║   P2:        │████│    │████│    │██│      (Burst: 10)                   ║\n * ║              └────┘    └────┘    └──┘                                     ║\n * ║                   ┌────┐    ┌──┐                                          ║\n * ║   P3:             │████│    │██│           (Burst: 6)                    ║\n * ║                   └────┘    └──┘                                          ║\n * ║                                                                           ║\n * ║   (Quantum = 4, processes rotate until complete)                         ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { SchedulingStrategy } from './SchedulingStrategy';\nexport class RoundRobinStrategy extends SchedulingStrategy {\n  /**\n   * Create Round Robin Strategy\n   * \n   * @param {number} timeQuantum - Time slice for each process (default: 4)\n   */\n  constructor(timeQuantum = 4) {\n    super();\n    this.name = 'Round Robin';\n    this.description = `Round Robin: Each process gets a fixed TIME QUANTUM (currently ${timeQuantum} units). \nWhen quantum expires, process moves to back of queue. This creates the ILLUSION OF PARALLELISM \nin time-sharing systems. Adjust the quantum slider to see the trade-off between \nresponsiveness and context switching overhead.`;\n\n    // Round Robin is PREEMPTIVE\n    // Process is preempted when its quantum expires\n    this.isPreemptive = true;\n    this.timeQuantum = timeQuantum;\n  }\n\n  /**\n   * Update the time quantum\n   * Called when user adjusts the quantum slider\n   * \n   * @param {number} quantum - New time quantum value\n   */\n  setTimeQuantum(quantum) {\n    this.timeQuantum = Math.max(1, Math.floor(quantum));\n    this.description = `Round Robin: Each process gets a fixed TIME QUANTUM (currently ${this.timeQuantum} units). \nWhen quantum expires, process moves to back of queue. This creates the ILLUSION OF PARALLELISM \nin time-sharing systems. Adjust the quantum slider to see the trade-off between \nresponsiveness and context switching overhead.`;\n  }\n\n  /**\n   * Select the next process in FIFO order\n   * \n   * Round Robin doesn't pick \"best\" process - it just goes around in a circle.\n   * The key is the PREEMPTION, not the selection.\n   * \n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - First process in queue\n   */\n  selectNext(readyQueue, currentTime) {\n    if (readyQueue.length === 0) {\n      return null;\n    }\n\n    /**\n     * ROUND ROBIN SELECTION:\n     * ──────────────────────\n     * Simply return the first process in the ready queue.\n     * \n     * The \"round robin\" behavior comes from:\n     * 1. Running process for its quantum\n     * 2. Moving it to the BACK of the queue if not complete\n     * 3. Next process gets its turn\n     * \n     * This creates a circular pattern where every process gets fair time.\n     */\n\n    return readyQueue[0];\n  }\n\n  /**\n   * Check if quantum has expired\n   * \n   * @param {Process} runningProcess - Currently running process\n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} quantumRemaining - Time remaining in current quantum\n   * @returns {boolean} - True if quantum expired\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    /**\n     * PREEMPTION IN ROUND ROBIN:\n     * ──────────────────────────\n     * Preempt ONLY when:\n     * 1. Quantum has expired (quantumRemaining <= 0)\n     * 2. There are other processes waiting\n     * \n     * If no other processes are waiting, let current process continue.\n     * (Why waste time on context switch if no one else wants the CPU?)\n     */\n\n    if (quantumRemaining <= 0 && readyQueue.length > 0) {\n      return true;\n    }\n    return false;\n  }\n}\nexport default RoundRobinStrategy;","map":{"version":3,"names":["SchedulingStrategy","RoundRobinStrategy","constructor","timeQuantum","name","description","isPreemptive","setTimeQuantum","quantum","Math","max","floor","selectNext","readyQueue","currentTime","length","shouldPreempt","runningProcess","quantumRemaining"],"sources":["/Users/belalraza/Desktop/osPROJECT/src/core/strategies/RoundRobinStrategy.js"],"sourcesContent":["/**\n * ╔═══════════════════════════════════════════════════════════════════════════╗\n * ║                    ROUND ROBIN (RR) STRATEGY                              ║\n * ╠═══════════════════════════════════════════════════════════════════════════╣\n * ║ The workhorse of time-sharing systems. Each process gets a fixed TIME     ║\n * ║ QUANTUM (time slice) to execute before being preempted.                   ║\n * ║                                                                           ║\n * ║ This is what creates the ILLUSION OF PARALLELISM!                        ║\n * ║                                                                           ║\n * ║ CHARACTERISTICS:                                                          ║\n * ║ ────────────────                                                          ║\n * ║ ✓ FAIR - every process gets equal CPU time                               ║\n * ║ ✓ No starvation (bounded waiting time)                                   ║\n * ║ ✓ Good response time for interactive processes                           ║\n * ║ ✓ Simple to implement                                                    ║\n * ║ ✗ Performance depends heavily on quantum size                            ║\n * ║ ✗ Context switching overhead with small quantum                          ║\n * ║ ✗ Higher average waiting time than SJF                                   ║\n * ║                                                                           ║\n * ║ ┌─────────────────────────────────────────────────────────────────────┐   ║\n * ║ │                    TIME QUANTUM TRADE-OFF                           │   ║\n * ║ ├─────────────────────────────────────────────────────────────────────┤   ║\n * ║ │                                                                     │   ║\n * ║ │  QUANTUM TOO LARGE:                                                │   ║\n * ║ │  ─────────────────                                                  │   ║\n * ║ │  - Degrades to FCFS behavior                                       │   ║\n * ║ │  - Poor response time                                              │   ║\n * ║ │  - Less \"parallelism illusion\"                                     │   ║\n * ║ │                                                                     │   ║\n * ║ │  QUANTUM TOO SMALL:                                                │   ║\n * ║ │  ─────────────────                                                  │   ║\n * ║ │  - Excessive context switching                                     │   ║\n * ║ │  - High overhead (CPU spends time switching, not computing)        │   ║\n * ║ │  - Throughput suffers                                              │   ║\n * ║ │                                                                     │   ║\n * ║ │  SWEET SPOT:                                                       │   ║\n * ║ │  ───────────                                                        │   ║\n * ║ │  Quantum should be large enough that most processes complete       │   ║\n * ║ │  within one quantum, but small enough for good responsiveness.     │   ║\n * ║ │                                                                     │   ║\n * ║ │  Rule of thumb: 80% of CPU bursts should be < quantum              │   ║\n * ║ │  Typical values: 10-100 milliseconds                               │   ║\n * ║ │                                                                     │   ║\n * ║ └─────────────────────────────────────────────────────────────────────┘   ║\n * ║                                                                           ║\n * ║ VISUALIZATION:                                                            ║\n * ║ ─────────────                                                             ║\n * ║                                                                           ║\n * ║   Time: 0    4    8    12   16   20   24   28                            ║\n * ║         |    |    |    |    |    |    |    |                              ║\n * ║         ┌────┐    ┌────┐    ┌────┐    ┌──┐                               ║\n * ║   P1:   │████│    │████│    │████│    │██│ (Burst: 14)                   ║\n * ║         └────┘    └────┘    └────┘    └──┘                               ║\n * ║              ┌────┐    ┌────┐    ┌──┐                                     ║\n * ║   P2:        │████│    │████│    │██│      (Burst: 10)                   ║\n * ║              └────┘    └────┘    └──┘                                     ║\n * ║                   ┌────┐    ┌──┐                                          ║\n * ║   P3:             │████│    │██│           (Burst: 6)                    ║\n * ║                   └────┘    └──┘                                          ║\n * ║                                                                           ║\n * ║   (Quantum = 4, processes rotate until complete)                         ║\n * ╚═══════════════════════════════════════════════════════════════════════════╝\n */\n\nimport { SchedulingStrategy } from './SchedulingStrategy';\n\nexport class RoundRobinStrategy extends SchedulingStrategy {\n  /**\n   * Create Round Robin Strategy\n   * \n   * @param {number} timeQuantum - Time slice for each process (default: 4)\n   */\n  constructor(timeQuantum = 4) {\n    super();\n    \n    this.name = 'Round Robin';\n    this.description = `Round Robin: Each process gets a fixed TIME QUANTUM (currently ${timeQuantum} units). \nWhen quantum expires, process moves to back of queue. This creates the ILLUSION OF PARALLELISM \nin time-sharing systems. Adjust the quantum slider to see the trade-off between \nresponsiveness and context switching overhead.`;\n    \n    // Round Robin is PREEMPTIVE\n    // Process is preempted when its quantum expires\n    this.isPreemptive = true;\n    this.timeQuantum = timeQuantum;\n  }\n  \n  /**\n   * Update the time quantum\n   * Called when user adjusts the quantum slider\n   * \n   * @param {number} quantum - New time quantum value\n   */\n  setTimeQuantum(quantum) {\n    this.timeQuantum = Math.max(1, Math.floor(quantum));\n    this.description = `Round Robin: Each process gets a fixed TIME QUANTUM (currently ${this.timeQuantum} units). \nWhen quantum expires, process moves to back of queue. This creates the ILLUSION OF PARALLELISM \nin time-sharing systems. Adjust the quantum slider to see the trade-off between \nresponsiveness and context switching overhead.`;\n  }\n  \n  /**\n   * Select the next process in FIFO order\n   * \n   * Round Robin doesn't pick \"best\" process - it just goes around in a circle.\n   * The key is the PREEMPTION, not the selection.\n   * \n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} currentTime - Current simulation time\n   * @returns {Process|null} - First process in queue\n   */\n  selectNext(readyQueue, currentTime) {\n    if (readyQueue.length === 0) {\n      return null;\n    }\n    \n    /**\n     * ROUND ROBIN SELECTION:\n     * ──────────────────────\n     * Simply return the first process in the ready queue.\n     * \n     * The \"round robin\" behavior comes from:\n     * 1. Running process for its quantum\n     * 2. Moving it to the BACK of the queue if not complete\n     * 3. Next process gets its turn\n     * \n     * This creates a circular pattern where every process gets fair time.\n     */\n    \n    return readyQueue[0];\n  }\n  \n  /**\n   * Check if quantum has expired\n   * \n   * @param {Process} runningProcess - Currently running process\n   * @param {Process[]} readyQueue - Processes waiting for CPU\n   * @param {number} quantumRemaining - Time remaining in current quantum\n   * @returns {boolean} - True if quantum expired\n   */\n  shouldPreempt(runningProcess, readyQueue, quantumRemaining) {\n    /**\n     * PREEMPTION IN ROUND ROBIN:\n     * ──────────────────────────\n     * Preempt ONLY when:\n     * 1. Quantum has expired (quantumRemaining <= 0)\n     * 2. There are other processes waiting\n     * \n     * If no other processes are waiting, let current process continue.\n     * (Why waste time on context switch if no one else wants the CPU?)\n     */\n    \n    if (quantumRemaining <= 0 && readyQueue.length > 0) {\n      return true;\n    }\n    \n    return false;\n  }\n}\n\nexport default RoundRobinStrategy;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,kBAAkB,QAAQ,sBAAsB;AAEzD,OAAO,MAAMC,kBAAkB,SAASD,kBAAkB,CAAC;EACzD;AACF;AACA;AACA;AACA;EACEE,WAAWA,CAACC,WAAW,GAAG,CAAC,EAAE;IAC3B,KAAK,CAAC,CAAC;IAEP,IAAI,CAACC,IAAI,GAAG,aAAa;IACzB,IAAI,CAACC,WAAW,GAAG,kEAAkEF,WAAW;AACpG;AACA;AACA,+CAA+C;;IAE3C;IACA;IACA,IAAI,CAACG,YAAY,GAAG,IAAI;IACxB,IAAI,CAACH,WAAW,GAAGA,WAAW;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEI,cAAcA,CAACC,OAAO,EAAE;IACtB,IAAI,CAACL,WAAW,GAAGM,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,KAAK,CAACH,OAAO,CAAC,CAAC;IACnD,IAAI,CAACH,WAAW,GAAG,kEAAkE,IAAI,CAACF,WAAW;AACzG;AACA;AACA,+CAA+C;EAC7C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,UAAUA,CAACC,UAAU,EAAEC,WAAW,EAAE;IAClC,IAAID,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;MAC3B,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEI,OAAOF,UAAU,CAAC,CAAC,CAAC;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,aAAaA,CAACC,cAAc,EAAEJ,UAAU,EAAEK,gBAAgB,EAAE;IAC1D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEI,IAAIA,gBAAgB,IAAI,CAAC,IAAIL,UAAU,CAACE,MAAM,GAAG,CAAC,EAAE;MAClD,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;AACF;AAEA,eAAed,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}